
/****************************************
 * Static methods / fields
 ****************************************/

interface PxTopLevelFunctions {
    static readonly attribute unsigned long PHYSICS_VERSION;
    
    [Value] static PxSimulationFilterShader DefaultFilterShader();

    static PxControllerManager CreateControllerManager([Ref] PxScene scene, optional boolean lockingEnabled);
    static PxCooking CreateCooking(unsigned long version, [Ref] PxFoundation foundation, [Const, Ref] PxCookingParams scale);
    static PxFoundation CreateFoundation(unsigned long version, [Ref] PxDefaultAllocator allocator, [Ref] PxErrorCallback errorCallback);
    static PxPhysics CreatePhysics(unsigned long version, [Ref] PxFoundation foundation, [Const, Ref] PxTolerancesScale params, optional PxPvd pvd);
    static PxDefaultCpuDispatcher DefaultCpuDispatcherCreate(unsigned long numThreads);
    static boolean InitExtensions([Ref] PxPhysics physics, optional PxPvd pvd);
    static PxCudaContextManager CreateCudaContextManager([Ref] PxFoundation foundation, [Const, Ref] PxCudaContextManagerDesc desc);
    static PxPvd CreatePvd([Ref] PxFoundation foundation);

    static PxD6Joint D6JointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxDistanceJoint DistanceJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxFixedJoint FixedJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxPrismaticJoint PrismaticJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxRevoluteJoint RevoluteJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxSphericalJoint SphericalJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
};

/****************************************
 * [package=physics]
 ****************************************/

[Prefix="physx::", NoDelete]
interface PxActor {
    PxActorTypeEnum getType();
    PxScene getScene();
    void setName(DOMString name);
    [Const] DOMString getName();
    [Value] PxBounds3 getWorldBounds(optional float inflation);
    void setActorFlags([Ref] PxActorFlags flags);
    [Value] PxActorFlags getActorFlags();
    void setDominanceGroup(octet dominanceGroup);
    octet getDominanceGroup();
    void setOwnerClient(octet inClient);
    octet getOwnerClient();

    attribute VoidPtr userData;
};
PxActor implements PxBase;

enum PxActorFlagEnum {
    "PxActorFlagEnum::eVISUALIZATION",
    "PxActorFlagEnum::eDISABLE_GRAVITY",
    "PxActorFlagEnum::eSEND_SLEEP_NOTIFIES",
    "PxActorFlagEnum::eDISABLE_SIMULATION"
};

[Prefix="physx::"]
interface PxActorFlags {
    void PxActorFlags(octet flags);
    boolean isSet(PxActorFlagEnum flag);
    void set(PxActorFlagEnum flag);
    void clear(PxActorFlagEnum flag);
};

[Prefix="physx::"]
interface PxActorShape {
    attribute PxRigidActor actor;
    attribute PxShape shape;
};

[Prefix="physx::"]
interface PxActorTypeFlags {
    void PxActorTypeFlags(unsigned short flags);
    boolean isSet(PxActorTypeFlagEnum flag);
    void set(PxActorTypeFlagEnum flag);
    void clear(PxActorTypeFlagEnum flag);
};

enum PxActorTypeEnum {
    "PxActorTypeEnum::eRIGID_STATIC",
    "PxActorTypeEnum::eRIGID_DYNAMIC",
    "PxActorTypeEnum::eARTICULATION_LINK",
    "PxActorTypeEnum::eACTOR_COUNT",
    "PxActorTypeEnum::eACTOR_FORCE_DWORD",
};

enum PxActorTypeFlagEnum {
    "PxActorTypeFlagEnum::eRIGID_STATIC",
    "PxActorTypeFlagEnum::eRIGID_DYNAMIC"
};

[Prefix="physx::", NoDelete]
interface PxAggregate {
    boolean addActor([Ref] PxActor actor, [Const] optional PxBVHStructure bvhStructure);
    boolean removeActor([Ref] PxActor actor);
    boolean addArticulation([Ref] PxArticulationBase articulation);
    boolean removeArticulation([Ref] PxArticulationBase articulation);
    unsigned long getNbActors();
    unsigned long getMaxNbActors();
    // unsigned long getActors();
    PxScene getScene();
    boolean getSelfCollision();
};
PxAggregate implements PxBase;

[Prefix="physx::", NoDelete]
interface PxArticulation {
    void setMaxProjectionIterations(unsigned long iterations);
    unsigned long getMaxProjectionIterations();
    void setSeparationTolerance(float tolerance);
    float getSeparationTolerance();
    void setInternalDriveIterations(unsigned long iterations);
    unsigned long getInternalDriveIterations();
    void setExternalDriveIterations(unsigned long iterations);
    unsigned long getExternalDriveIterations();
    PxArticulationDriveCache createDriveCache(float compliance, unsigned long driveIterations);
    void updateDriveCache([Ref] PxArticulationDriveCache driveCache, float compliance, unsigned long driveIterations);
    void releaseDriveCache([Ref] PxArticulationDriveCache driveCache);
    void applyImpulse(PxArticulationLink link, [Const, Ref] PxArticulationDriveCache driveCache, [Const, Ref] PxVec3 linearImpulse, [Const, Ref] PxVec3 angularImpulse);
    void computeImpulseResponse(PxArticulationLink link, [Ref] PxVec3 linearResponse, [Ref] PxVec3 angularResponse,
                [Const, Ref] PxArticulationDriveCache driveCache, [Const, Ref] PxVec3 linearImpulse, [Const, Ref] PxVec3 angularImpulse);
};
PxArticulation implements PxArticulationBase;

enum PxArticulationAxisEnum {
    "PxArticulationAxisEnum::eTWIST",
    "PxArticulationAxisEnum::eSWING1",
    "PxArticulationAxisEnum::eSWING2",
    "PxArticulationAxisEnum::eX",
    "PxArticulationAxisEnum::eY",
    "PxArticulationAxisEnum::eZ",
    "PxArticulationAxisEnum::eCOUNT"
};

[Prefix="physx::", NoDelete]
interface PxArticulationBase {
    PxScene getScene();
    void setSolverIterationCounts(unsigned long minPositionIters, unsigned long minVelocityIters);
    // void getSolverIterationCounts(unsigned long minPositionIters, unsigned long minVelocityIters);
    boolean isSleeping();
    void setSleepThreshold(float threshold);
    float getSleepThreshold();
    void setStabilizationThreshold(float threshold);
    float getStabilizationThreshold();
    void setWakeCounter(float wakeCounterValue);
    float getWakeCounter();
    void wakeUp();
    void putToSleep();
    PxArticulationLink createLink(PxArticulationLink parent, [Const, Ref] PxTransform pose);
    unsigned long getNbLinks();
    // unsigned long getLinks(PxArticulationLink**);
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    [Value] PxBounds3 getWorldBounds();
    PxAggregate getAggregate();
};
PxArticulationBase implements PxBase;

[Prefix="physx::", NoDelete]
interface PxArticulationCache { };

enum PxArticulationCacheEnum {
    "PxArticulationCacheEnum::eVELOCITY",
    "PxArticulationCacheEnum::eACCELERATION",
    "PxArticulationCacheEnum::ePOSITION",
    "PxArticulationCacheEnum::eFORCE",
    "PxArticulationCacheEnum::eLINKVELOCITY",
    "PxArticulationCacheEnum::eLINKACCELERATION",
    "PxArticulationCacheEnum::eROOT",
    "PxArticulationCacheEnum::eALL",
};

[Prefix="physx::"]
interface PxArticulationCacheFlags {
    void PxArticulationCacheFlags(octet flags);
    boolean isSet(PxArticulationCacheEnum flag);
    void set(PxArticulationCacheEnum flag);
    void clear(PxArticulationCacheEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxArticulationDriveCache { };

enum PxArticulationDriveTypeEnum {
    "PxArticulationDriveTypeEnum::eFORCE",
    "PxArticulationDriveTypeEnum::eACCELERATION",
    "PxArticulationDriveTypeEnum::eTARGET",
    "PxArticulationDriveTypeEnum::eVELOCITY",
    "PxArticulationDriveTypeEnum::eNONE",
};

enum PxArticulationFlagEnum {
    "PxArticulationFlagEnum::eFIX_BASE",
    "PxArticulationFlagEnum::eDRIVE_LIMITS_ARE_FORCES"
};

[Prefix="physx::"]
interface PxArticulationFlags {
    void PxArticulationFlags(octet flags);
    boolean isSet(PxArticulationFlagEnum flag);
    void set(PxArticulationFlagEnum flag);
    void clear(PxArticulationFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxArticulationJoint {
    void setTargetOrientation([Const, Ref] PxQuat orientation);
    [Value] PxQuat getTargetOrientation();
    void setTargetVelocity([Const, Ref] PxVec3 velocity);
    [Value] PxVec3 getTargetVelocity();
    void setDriveType(PxArticulationJointDriveTypeEnum driveType);
    PxArticulationJointDriveTypeEnum getDriveType();
    void setStiffness(float spring);
    float getStiffness();
    void setDamping(float damping);
    float getDamping();
    void setInternalCompliance(float compliance);
    float getInternalCompliance();
    void setExternalCompliance(float compliance);
    float getExternalCompliance();
    void setSwingLimit(float zLimit, float yLimit);
    // void getSwingLimit(float zLimit, float yLimit);
    void setTangentialStiffness(float spring);
    float getTangentialStiffness();
    void setTangentialDamping(float damping);
    float getTangentialDamping();
    void setSwingLimitContactDistance(float contactDistance);
    float getSwingLimitContactDistance();
    void setSwingLimitEnabled(boolean enabled);
    boolean getSwingLimitEnabled();
    void setTwistLimit(float lower, float upper);
    // void getTwistLimit(float lower, float upper);
    void setTwistLimitEnabled(boolean enabled);
    boolean getTwistLimitEnabled();
    void setTwistLimitContactDistance(float contactDistance);
    float getTwistLimitContactDistance();
};
PxArticulationJoint implements PxArticulationJointBase;

[Prefix="physx::", NoDelete]
interface PxArticulationJointBase {
    [Ref] PxArticulationLink getParentArticulationLink();
    void setParentPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getParentPose();
    [Ref] PxArticulationLink getChildArticulationLink();
    void setChildPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getChildPose();
};
PxArticulationJointBase implements PxBase;

enum PxArticulationJointDriveTypeEnum {
    "PxArticulationJointDriveTypeEnum::eTARGET",
    "PxArticulationJointDriveTypeEnum::eERROR"
};

enum PxArticulationMotionEnum {
    "PxArticulationMotionEnum::eLOCKED",
    "PxArticulationMotionEnum::eLIMITED",
    "PxArticulationMotionEnum::eFREE"
};

[Prefix="physx::", NoDelete]
interface PxArticulationJointReducedCoordinate {
    void setJointType(PxArticulationJointTypeEnum jointType);
    PxArticulationJointTypeEnum getJointType();
    void setMotion(PxArticulationAxisEnum axis, PxArticulationMotionEnum motion);
    PxArticulationMotionEnum getMotion(PxArticulationAxisEnum axis);
    void setLimit(PxArticulationAxisEnum axis, float lowLimit, float highLimit);
    // void getLimit(PxArticulationAxisEnum axis, float lowLimit, float highLimit);
    void setDrive(PxArticulationAxisEnum axis, float stiffness, float damping, float maxForce, optional PxArticulationDriveTypeEnum driveType);
    // void getDrive(PxArticulationAxisEnum axis, float stiffness, float damping, float maxForce, optional PxArticulationJointDriveTypeEnum driveType);
    void setDriveTarget(PxArticulationAxisEnum axis, float target);
    void setDriveVelocity(PxArticulationAxisEnum axis, float targetVel);
    float getDriveTarget(PxArticulationAxisEnum axis);
    float getDriveVelocity(PxArticulationAxisEnum axis);
    void setFrictionCoefficient(float coefficient);
    float getFrictionCoefficient();
    void setMaxJointVelocity(float maxJointV);
    float getMaxJointVelocity();
};
PxArticulationJointReducedCoordinate implements PxArticulationJointBase;

enum PxArticulationJointTypeEnum {
    "PxArticulationJointTypeEnum::ePRISMATIC",
    "PxArticulationJointTypeEnum::eREVOLUTE",
    "PxArticulationJointTypeEnum::eSPHERICAL",
    "PxArticulationJointTypeEnum::eFIX",
    "PxArticulationJointTypeEnum::eUNDEFINED"
};

[Prefix="physx::", NoDelete]
interface PxArticulationLink {
    [Ref] PxArticulationBase getArticulation();
    PxArticulationJointBase getInboundJoint();
    unsigned long getInboundJointDof();
    unsigned long getNbChildren();
    unsigned long getLinkIndex();
    // unsigned long getChildren();
};
PxArticulationLink implements PxRigidBody;

[Prefix="physx::", NoDelete]
interface PxArticulationReducedCoordinate {
    void setArticulationFlags([Ref] PxArticulationFlags flags);
    void setArticulationFlag(PxArticulationFlagEnum flag, boolean value);
    [Value] PxArticulationFlags getArticulationFlags();
    unsigned long getDofs();
    PxArticulationCache createCache();
    unsigned long getCacheDataSize();
    void zeroCache([Ref] PxArticulationCache cache);
    void applyCache([Ref] PxArticulationCache cache, [Const, Ref] PxArticulationCacheFlags flag, optional boolean autowake);
    void copyInternalStateToCache([Ref] PxArticulationCache cache, [Const, Ref] PxArticulationCacheFlags flag);
    void releaseCache([Ref] PxArticulationCache cache);
    void packJointData([Ref] PxRealPtr maximum, [Ref] PxRealPtr reduced);
    void unpackJointData([Ref] PxRealPtr reduced, [Ref] PxRealPtr maximum);
    void commonInit();
    void computeGeneralizedGravityForce([Ref] PxArticulationCache cache);
    void computeCoriolisAndCentrifugalForce([Ref] PxArticulationCache cache);
    void computeGeneralizedExternalForce([Ref] PxArticulationCache cache);
    void computeJointAcceleration([Ref] PxArticulationCache cache);
    void computeJointForce([Ref] PxArticulationCache cache);
    // void computeDenseJacobian([Ref] PxArticulationCache cache, [Ref] unsigned long nRows, [Ref] unsigned long nCols);
    void computeCoefficientMatrix([Ref] PxArticulationCache cache);
    void computeLambda([Ref] PxArticulationCache cache, [Ref] PxArticulationCache initialState, [Ref] PxRealPtr jointTorque, unsigned long maxIter);
    void computeGeneralizedMassMatrix([Ref] PxArticulationCache cache);
    void addLoopJoint(PxJoint joint);
    void removeLoopJoint(PxJoint joint);
    unsigned long getNbLoopJoints();
    // void getLoopJoints();
    unsigned long getCoefficientMatrixSize();
    void teleportRootLink([Const, Ref] PxTransform pose, boolean autowake);
    [Value] PxSpatialVelocity getLinkVelocity(unsigned long linkId);
    [Value] PxSpatialVelocity getLinkAcceleration(unsigned long linkId);
};
PxArticulationReducedCoordinate implements PxArticulationBase;

[Prefix="physx::", NoDelete]
interface PxBatchQuery {
    void execute();
    [Value] PxBatchQueryPreFilterShader getPreFilterShader();
    [Value] PxBatchQueryPostFilterShader getPostFilterShader();
    [Const] any getFilterShaderData();
    unsigned long getFilterShaderDataSize();
    void setUserMemory([Const, Ref] PxBatchQueryMemory userMemory);
    [Const, Ref] PxBatchQueryMemory getUserMemory();
    void release();
};

[Prefix="physx::"]
interface PxBatchQueryDesc {
    void PxBatchQueryDesc(unsigned long maxRaycastsPerExecute, unsigned long maxSweepsPerExecute, unsigned long maxOverlapsPerExecute);
    boolean isValid();
    attribute any filterShaderData;
    attribute unsigned long filterShaderDataSize;
    [Value] attribute PxBatchQueryPreFilterShader preFilterShader;
    [Value] attribute PxBatchQueryPostFilterShader postFilterShader;
    [Value] attribute PxBatchQueryMemory queryMemory;
};

[Prefix="physx::"]
interface PxBatchQueryMemory {
    attribute PxRaycastQueryResult userRaycastResultBuffer;
    attribute PxRaycastHit userRaycastTouchBuffer;
    attribute PxSweepQueryResult userSweepResultBuffer;
    attribute PxSweepHit userSweepTouchBuffer;
    attribute PxOverlapQueryResult userOverlapResultBuffer;
    attribute PxOverlapHit userOverlapTouchBuffer;
    attribute unsigned long raycastTouchBufferSize;
    attribute unsigned long sweepTouchBufferSize;
    attribute unsigned long overlapTouchBufferSize;
};

[Prefix="physx::"]
interface PxBatchQueryPostFilterShader { };

[Prefix="physx::"]
interface PxBatchQueryPreFilterShader { };

[Prefix="physx::"]
interface PxBroadPhaseCaps {
    void PxBroadPhaseCaps();
    attribute unsigned long maxNbRegions;
    attribute unsigned long maxNbObjects;
    attribute boolean needsPredefinedBounds;
};

[Prefix="physx::"]
interface PxBroadPhaseRegion {
    void PxBroadPhaseRegion();
    [Value] attribute PxBounds3 bounds;
    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxBroadPhaseRegionInfo {
    void PxBroadPhaseRegionInfo();
    [Value] attribute PxBroadPhaseRegion region;
    attribute unsigned long nbStaticObjects;
    attribute unsigned long nbDynamicObjects;
    attribute boolean active;
    attribute boolean overlap;
};

enum PxBroadPhaseTypeEnum {
    "PxBroadPhaseTypeEnum::eSAP",
    "PxBroadPhaseTypeEnum::eMBP",
    "PxBroadPhaseTypeEnum::eABP",
    "PxBroadPhaseTypeEnum::eGPU",
    "PxBroadPhaseTypeEnum::eLAST"
};

[Prefix="physx::", NoDelete]
interface PxConstraint {
    void release();
    PxScene getScene();
    //void getActors();
    void setActors(PxRigidActor actor0, PxRigidActor actor1);
    void markDirty();
    void setFlags([Ref] PxConstraintFlags flags);
    [Value] PxConstraintFlags getFlags();
    void setFlag(PxConstraintFlagEnum flag, boolean value);
    void getForce([Ref] PxVec3 linear, [Ref] PxVec3 angular);
    boolean isValid();
    void setBreakForce(float linear, float angular);
    //void getBreakForce
    void setMinResponseThreshold(float threshold);
    float getMinResponseThreshold();
    //VoidPtr getExternalReference
    //void setConstraintFunctions
};
PxConstraint implements PxBase;

enum PxConstraintFlagEnum {
    "PxConstraintFlagEnum::eBROKEN",
    "PxConstraintFlagEnum::ePROJECT_TO_ACTOR0",
    "PxConstraintFlagEnum::ePROJECT_TO_ACTOR1",
    "PxConstraintFlagEnum::ePROJECTION",
    "PxConstraintFlagEnum::eCOLLISION_ENABLED",
    "PxConstraintFlagEnum::eVISUALIZATION",
    "PxConstraintFlagEnum::eDRIVE_LIMITS_ARE_FORCES",
    "PxConstraintFlagEnum::eIMPROVED_SLERP",
    "PxConstraintFlagEnum::eDISABLE_PREPROCESSING",
    "PxConstraintFlagEnum::eENABLE_EXTENDED_LIMITS",
    "PxConstraintFlagEnum::eGPU_COMPATIBLE"
};

[Prefix="physx::"]
interface PxConstraintFlags {
    void PxConstraintFlags(unsigned short flags);
    boolean isSet(PxConstraintFlagEnum flag);
    void set(PxConstraintFlagEnum flag);
    void clear(PxConstraintFlagEnum flag);
};

[Prefix="physx::"]
interface PxConstraintInfo {
    attribute PxConstraint constraint;
    attribute VoidPtr externalReference;
    attribute unsigned long type;
};

enum PxContactPairHeaderFlagEnum {
    "PxContactPairHeaderFlagEnum::eREMOVED_ACTOR_0",
    "PxContactPairHeaderFlagEnum::eREMOVED_ACTOR_1"
};

[Prefix="physx::"]
interface PxContactPairHeaderFlags {
    void PxContactPairHeaderFlags(unsigned short flags);
    boolean isSet(PxContactPairHeaderFlagEnum flag);
    void set(PxContactPairHeaderFlagEnum flag);
    void clear(PxContactPairHeaderFlagEnum flag);
};

[Prefix="physx::"]
interface PxContactPair {
    attribute PxShape[] shapes;
    attribute octet contactCount;
    attribute octet patchCount;
    [Value] attribute PxContactPairFlags flags;
    [Value] attribute PxPairFlags events;
};

enum PxContactPairFlagEnum {
    "PxContactPairFlagEnum::eREMOVED_SHAPE_0",
    "PxContactPairFlagEnum::eREMOVED_SHAPE_1",
    "PxContactPairFlagEnum::eACTOR_PAIR_HAS_FIRST_TOUCH",
    "PxContactPairFlagEnum::eACTOR_PAIR_LOST_TOUCH",
    "PxContactPairFlagEnum::eINTERNAL_HAS_IMPULSES",
    "PxContactPairFlagEnum::eINTERNAL_CONTACTS_ARE_FLIPPED"
};

[Prefix="physx::"]
interface PxContactPairFlags {
    void PxContactPairFlags(unsigned short flags);
    boolean isSet(PxContactPairFlagEnum flag);
    void set(PxContactPairFlagEnum flag);
    void clear(PxContactPairFlagEnum flag);
};

[Prefix="physx::"]
interface PxContactPairHeader {
    attribute PxRigidActor[] actors;
    //attribute PxU8ConstPtr extraDataStream;
    //attribute short extraDataStreamSize;
    [Value] attribute PxContactPairHeaderFlags flags;
    [Const] attribute PxContactPair pairs;
    attribute unsigned long nbPairs;
};

[Prefix="physx::"]
interface PxDominanceGroupPair {
    void PxDominanceGroupPair(octet a, octet b);
    attribute octet dominance0;
    attribute octet dominance1;
};

[Prefix="physx::"]
interface PxgDynamicsMemoryConfig {
    void PxgDynamicsMemoryConfig();
    attribute unsigned long constraintBufferCapacity;
    attribute unsigned long contactBufferCapacity;
    attribute unsigned long tempBufferCapacity;
    attribute unsigned long contactStreamSize;
    attribute unsigned long patchStreamSize;
    attribute unsigned long forceStreamCapacity;
    attribute unsigned long heapCapacity;
    attribute unsigned long foundLostPairsCapacity;
};

[Prefix="physx::"]
interface PxFilterData {
    void PxFilterData();
    void PxFilterData(unsigned long w0, unsigned long w1, unsigned long w2, unsigned long w3);
    attribute unsigned long word0;
    attribute unsigned long word1;
    attribute unsigned long word2;
    attribute unsigned long word3;
};

enum PxForceModeEnum {
    "PxForceModeEnum::eFORCE",
    "PxForceModeEnum::eIMPULSE",
    "PxForceModeEnum::eVELOCITY_CHANGE",
    "PxForceModeEnum::eACCELERATION"
};

enum PxFrictionTypeEnum {
    "PxFrictionTypeEnum::ePATCH",
    "PxFrictionTypeEnum::eONE_DIRECTIONAL",
    "PxFrictionTypeEnum::eTWO_DIRECTIONAL",
    "PxFrictionTypeEnum::eFRICTION_COUNT"
};

enum PxHitFlagEnum {
    "PxHitFlagEnum::ePOSITION",
    "PxHitFlagEnum::eNORMAL",
    "PxHitFlagEnum::eUV",
    "PxHitFlagEnum::eASSUME_NO_INITIAL_OVERLAP",
    "PxHitFlagEnum::eMESH_MULTIPLE",
    "PxHitFlagEnum::eMESH_ANY",
    "PxHitFlagEnum::eMESH_BOTH_SIDES",
    "PxHitFlagEnum::ePRECISE_SWEEP",
    "PxHitFlagEnum::eMTD",
    "PxHitFlagEnum::eFACE_INDEX",
    "PxHitFlagEnum::eDEFAULT",
    "PxHitFlagEnum::eMODIFIABLE_FLAGS"
};

[Prefix="physx::"]
interface PxHitFlags {
    void PxHitFlags(unsigned short flags);
    boolean isSet(PxHitFlagEnum flag);
    void set(PxHitFlagEnum flag);
    void clear(PxHitFlagEnum flag);
};

[Prefix="physx::"]
interface PxLocationHit {
    [Value] attribute PxHitFlags flags;
    [Value] attribute PxVec3 position;
    [Value] attribute PxVec3 normal;
    attribute float distance;
};
PxLocationHit implements PxQueryHit;

interface PxOverlapBuffer10 {
    void PxOverlapBuffer10();
    unsigned long getNbAnyHits();
    [Const, Ref] PxOverlapHit getAnyHit(unsigned long index);
    unsigned long getNbTouches();
    [Const] PxOverlapHit getTouches();
    [Const, Ref] PxOverlapHit getTouch(unsigned long index);
    unsigned long getMaxNbTouches();
    [Value] attribute PxOverlapHit block;
    attribute boolean hasBlock;
};
PxOverlapBuffer10 implements PxOverlapCallback;

[Prefix="physx::"]
interface PxOverlapCallback {
    boolean hasAnyHits();
};

[Prefix="physx::"]
interface PxOverlapHit { };
PxOverlapHit implements PxQueryHit;

[Prefix="physx::"]
interface PxOverlapQueryResult {
    unsigned long getNbAnyHits();
    [Const, Ref] PxOverlapHit getAnyHit(unsigned long index);
    [Value] attribute PxOverlapHit block;
    attribute PxOverlapHit touches;
    attribute unsigned long nbTouches;
    attribute any userData; 
    attribute octet queryStatus;
    attribute boolean hasBlock;
};

[Prefix="physx::", NoDelete]
interface PxMaterial {
    attribute VoidPtr userData;
};
PxMaterial implements PxBase;

enum PxPairFilteringModeEnum {
    "PxPairFilteringModeEnum::eKEEP",
    "PxPairFilteringModeEnum::eSUPPRESS",
    "PxPairFilteringModeEnum::eKILL",
    "PxPairFilteringModeEnum::eDEFAULT",
};

enum PxPairFlagEnum {
    "PxPairFlagEnum::eSOLVE_CONTACT",
    "PxPairFlagEnum::eMODIFY_CONTACTS",
    "PxPairFlagEnum::eNOTIFY_TOUCH_FOUND",
    "PxPairFlagEnum::eNOTIFY_TOUCH_PERSISTS",
    "PxPairFlagEnum::eNOTIFY_TOUCH_LOST",
    "PxPairFlagEnum::eNOTIFY_TOUCH_CCD",
    "PxPairFlagEnum::eNOTIFY_THRESHOLD_FORCE_FOUND",
    "PxPairFlagEnum::eNOTIFY_THRESHOLD_FORCE_PERSISTS",
    "PxPairFlagEnum::eNOTIFY_THRESHOLD_FORCE_LOST",
    "PxPairFlagEnum::eNOTIFY_CONTACT_POINTS",
    "PxPairFlagEnum::eDETECT_DISCRETE_CONTACT",
    "PxPairFlagEnum::eDETECT_CCD_CONTACT",
    "PxPairFlagEnum::ePRE_SOLVER_VELOCITY",
    "PxPairFlagEnum::ePOST_SOLVER_VELOCITY",
    "PxPairFlagEnum::eCONTACT_EVENT_POSE",
    "PxPairFlagEnum::eNEXT_FREE",
    "PxPairFlagEnum::eCONTACT_DEFAULT"
};

[Prefix="physx::"]
interface PxPairFlags {
    void PxPairFlags(unsigned short flags);
    boolean isSet(PxPairFlagEnum flag);
    void set(PxPairFlagEnum flag);
    void clear(PxPairFlagEnum flag);
};

[Prefix="physx::"]
interface PxPhysics {
    // Basics
    void release();
    [Ref] PxFoundation getFoundation();
    PxAggregate createAggregate(unsigned long size, boolean enableSelfCollision);
    [Const, Ref] PxTolerancesScale getTolerancesScale();
    // Scenes
    PxScene createScene([Const, Ref] PxSceneDesc sceneDesc);
    // Actors
    PxRigidStatic createRigidStatic([Const, Ref] PxTransform pose);
    PxRigidDynamic createRigidDynamic([Const, Ref] PxTransform pose);
    // Shapes
    PxShape createShape([Const, Ref] PxGeometry geometry, [Const, Ref] PxMaterial material, optional boolean isExclusive, [Ref] optional PxShapeFlags shapeFlags);
    long getNbShapes();
    // Constraints and Articulations
    PxArticulation createArticulation();
    PxArticulationReducedCoordinate createArticulationReducedCoordinate();
    // Materials
    PxMaterial createMaterial(float staticFriction, float dynamicFriction, float restitution);
    // Deletion Listeners
    [Ref] PxPhysicsInsertionCallback getPhysicsInsertionCallback();
};

enum PxPruningStructureTypeEnum {
    "PxPruningStructureTypeEnum::eNONE",
    "PxPruningStructureTypeEnum::eDYNAMIC_AABB_TREE",
    "PxPruningStructureTypeEnum::eSTATIC_AABB_TREE",
    "PxPruningStructureTypeEnum::eLAST"
};

[Prefix="physx::"]
interface PxQueryFilterData {
    void PxQueryFilterData();
    void PxQueryFilterData([Const, Ref] PxFilterData fd, [Ref] PxQueryFlags f);
    void PxQueryFilterData([Ref] PxQueryFlags f);
    [Value] attribute PxFilterData data;
    [Value] attribute PxQueryFlags flags;
};

enum PxQueryFlagEnum {
    "PxQueryFlagEnum::eSTATIC",
    "PxQueryFlagEnum::eDYNAMIC",
    "PxQueryFlagEnum::ePREFILTER",
    "PxQueryFlagEnum::ePOSTFILTER",
    "PxQueryFlagEnum::eANY_HIT",
    "PxQueryFlagEnum::eNO_BLOCK"
};

[Prefix="physx::"]
interface PxQueryFlags {
    void PxQueryFlags(unsigned short flags);
    boolean isSet(PxQueryFlagEnum flag);
    void set(PxQueryFlagEnum flag);
    void clear(PxQueryFlagEnum flag);
};

[Prefix="physx::"]
interface PxQueryHit {
    attribute unsigned long faceIndex;
};
PxQueryHit implements PxActorShape;

interface PxRaycastBuffer10 {
    void PxRaycastBuffer10();
    unsigned long getNbAnyHits();
    [Const, Ref] PxRaycastHit getAnyHit(unsigned long index);
    unsigned long getNbTouches();
    [Const] PxRaycastHit getTouches();
    [Const, Ref] PxRaycastHit getTouch(unsigned long index);
    unsigned long getMaxNbTouches();
    [Value] attribute PxRaycastHit block;
    attribute boolean hasBlock;
};
PxRaycastBuffer10 implements PxRaycastCallback;

[Prefix="physx::"]
interface PxRaycastCallback {
    boolean hasAnyHits();
};

[Prefix="physx::"]
interface PxRaycastHit {
    void PxRaycastHit();
    attribute float u;
    attribute float v;
};
PxRaycastHit implements PxLocationHit;

[Prefix="physx::"]
interface PxRaycastQueryResult {
    unsigned long getNbAnyHits();
    [Const, Ref] PxRaycastHit getAnyHit(unsigned long index);
    [Value] attribute PxRaycastHit block;
    attribute PxRaycastHit touches;
    attribute unsigned long nbTouches;
    attribute any userData; 
    attribute octet queryStatus;
    attribute boolean hasBlock;
};

[Prefix="physx::", NoDelete]
interface PxRigidActor {
    // Global Pose Manipulation
    [Value] PxTransform getGlobalPose();
    void setGlobalPose([Const, Ref] PxTransform pose, optional boolean autowake);

    // Shapes
    boolean attachShape([Ref] PxShape shape);
    void detachShape([Ref] PxShape shape, optional boolean wakeOnLostTouch);
    long getNbShapes();
    //long getShapes(PxShape[] userBuffer, unsigned long bufferSize, unsigned long startIndex);
};
PxRigidActor implements PxActor;

[Prefix="physx::", NoDelete]
interface PxRigidBody {
    // Mass Manipulation
    void setCMassLocalPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getCMassLocalPose();
    void setMass(float mass);
    float getMass();
    float getInvMass();
    void setMassSpaceInertiaTensor([Const, Ref] PxVec3 m);
    [Value] PxVec3 getMassSpaceInertiaTensor();
    [Value] PxVec3 getMassSpaceInvInertiaTensor();

    // Damping
    void setLinearDamping(float linDamp);
    float getLinearDamping();
    void setAngularDamping(float angDamp);
    float getAngularDamping();

    // Velocity
    [Value] PxVec3 getLinearVelocity();
    void setLinearVelocity([Const, Ref] PxVec3 linVel, optional boolean autowake);
    [Value] PxVec3 getAngularVelocity();
    void setAngularVelocity([Const, Ref] PxVec3 angVel, optional boolean autowake);
    float getMaxLinearVelocity();
    void setMaxLinearVelocity(float maxLinVel);
    float getMaxAngularVelocity();
    void setMaxAngularVelocity(float maxAngVel);

    // Forces
    void addForce([Const, Ref] PxVec3 force, optional PxForceModeEnum mode, optional boolean autowake);
    void addTorque([Const, Ref] PxVec3 torque, optional PxForceModeEnum mode, optional boolean autowake);
    void clearForce(PxForceModeEnum mode);
    void clearTorque(PxForceModeEnum mode);
    void setForceAndTorque([Const, Ref] PxVec3 force, [Const, Ref] PxVec3 torque, optional PxForceModeEnum mode);

    void setRigidBodyFlag(PxRigidBodyFlagEnum flag, boolean value);
    void setRigidBodyFlags([Ref] PxRigidBodyFlags inFlags);
    [Value] PxRigidBodyFlags getRigidBodyFlags();
    void setMinCCDAdvanceCoefficient(float advanceCoefficient);
    float getMinCCDAdvanceCoefficient();
    void setMaxDepenetrationVelocity(float biasClamp);
    float getMaxDepenetrationVelocity();
    void setMaxContactImpulse(float maxImpulse);
    float getMaxContactImpulse();
    unsigned long getInternalIslandNodeIndex();
};
PxRigidBody implements PxRigidActor;

enum PxRigidBodyFlagEnum {
    "PxRigidBodyFlagEnum::eKINEMATIC",
    "PxRigidBodyFlagEnum::eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES",
    "PxRigidBodyFlagEnum::eENABLE_CCD",
    "PxRigidBodyFlagEnum::eENABLE_CCD_FRICTION",
    "PxRigidBodyFlagEnum::eENABLE_POSE_INTEGRATION_PREVIEW",
    "PxRigidBodyFlagEnum::eENABLE_SPECULATIVE_CCD",
    "PxRigidBodyFlagEnum::eENABLE_CCD_MAX_CONTACT_IMPULSE",
    "PxRigidBodyFlagEnum::eRETAIN_ACCELERATIONS"
};

[Prefix="physx::"]
interface PxRigidBodyFlags {
    void PxRigidBodyFlags(octet flags);
    boolean isSet(PxRigidBodyFlagEnum flag);
    void set(PxRigidBodyFlagEnum flag);
    void clear(PxRigidBodyFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidDynamic {
    void setKinematicTarget([Const, Ref] PxTransform destination);
    boolean getKinematicTarget([Ref] PxTransform target);
    boolean isSleeping();
    void setSleepThreshold(float threshold);
    float getSleepThreshold();
    void setStabilizationThreshold(float threshold);
    float getStabilizationThreshold();
    [Value] PxRigidDynamicLockFlags getRigidDynamicLockFlags();
    void setRigidDynamicLockFlag(PxRigidDynamicLockFlagEnum flag, boolean value);
    void setRigidDynamicLockFlags([Ref] PxRigidDynamicLockFlags flags);
    void setWakeCounter(float wakeCounterValue);
    float getWakeCounter();
    void wakeUp();
    void putToSleep();
    void setSolverIterationCounts(unsigned long minPositionIters, optional unsigned long minVelocityIters);
    float getContactReportThreshold();
    void setContactReportThreshold(float threshold);
};
PxRigidDynamic implements PxRigidBody;

enum PxRigidDynamicLockFlagEnum {
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_X",
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_Y",
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_Z",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_X",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_Y",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_Z",
};

[Prefix="physx::"]
interface PxRigidDynamicLockFlags {
    void PxRigidDynamicLockFlags(octet flags);
    boolean isSet(PxRigidDynamicLockFlagEnum flag);
    void set(PxRigidDynamicLockFlagEnum flag);
    void clear(PxRigidDynamicLockFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidStatic { };
PxRigidStatic implements PxRigidActor;

[Prefix="physx::", NoDelete]
interface PxScene {
    void addActor([Ref] PxActor actor, [Const] optional PxBVHStructure bvhStructure);
    void removeActor([Ref] PxActor actor, optional boolean wakeOnLostTouch);
    void addAggregate([Ref] PxAggregate aggregate);
    void removeAggregate([Ref] PxAggregate aggregate, optional boolean wakeOnLostTouch);
    float getWakeCounterResetValue();
    void shiftOrigin([Const, Ref] PxVec3 shift);

    // Add/Remove Contained Objects
    void addArticulation([Ref] PxArticulationBase articulation);
    void removeArticulation([Ref] PxArticulationBase articulation, optional boolean wakeOnLostTouch);

    // Contained Object Retrieval
    unsigned long getNbActors([Ref] PxActorTypeFlags types);
    // unsigned long getActors(...)
    // PxActorPtr getActiveActors();
    unsigned long getNbArticulations();
    // unsigned long getArticulations(...);
    unsigned long getNbConstraints();
    // unsigned long getConstraints(...);
    unsigned long getNbAggregates();
    // unsigned long getAggregates(...);

    // Dominance
    void setDominanceGroupPair(octet group1, octet group2, [Const, Ref] PxDominanceGroupPair dominance);
    //[Value] PxDominanceGroupPair getDominanceGroupPair(octet group1, octet group2);

    // Dispatcher
    PxCpuDispatcher getCpuDispatcher();
    PxCudaContextManager getCudaContextManager();

    // Multiclient
    octet createClient();

    // Callbacks
    void setSimulationEventCallback(PxSimulationEventCallback callback);
    PxSimulationEventCallback getSimulationEventCallback();
    // set/get contact modify callback
    // set/get ccd contact modify callback
    // set/get broad phase callback

    // collision filtering
    void setFilterShaderData([Const] VoidPtr data, unsigned long dataSize);
    [Const] VoidPtr getFilterShaderData();
    unsigned long getFilterShaderDataSize();
    [Value] PxSimulationFilterShader getFilterShader();
    //PxSimulationFilterCallback getFilterCallback();
    void resetFiltering([Ref] PxActor actor);
    // void resetFiltering([Ref] PxActor actor, ...);
    PxPairFilteringModeEnum getKinematicKinematicFilteringMode();
    PxPairFilteringModeEnum getStaticKinematicFilteringMode();

    // Simulation
    void simulate(float elapsedTime, optional PxBaseTask completionTask, optional VoidPtr scratchMemBlock, optional unsigned long scratchMemBlockSize, optional boolean controlSimulation);
    void advance(optional PxBaseTask completionTask);
    void collide(float elapsedTime, optional PxBaseTask completionTask, optional VoidPtr scratchMemBlock, optional unsigned long scratchMemBlockSize, optional boolean controlSimulation);
    boolean checkResults(optional boolean block);
    boolean fetchCollision(optional boolean block);
    boolean fetchResults(optional boolean block);
    // boolean fetchResultsStart();
    void processCallbacks(PxBaseTask continuation);
    // boolean fetchResultsFinish();
    void flushSimulation(optional boolean sendPendingReports);
    void setGravity([Const, Ref] PxVec3 vec);
    [Value] PxVec3 getGravity();
    void setBounceThresholdVelocity(float t);
    float getBounceThresholdVelocity();
    void setCCDMaxPasses(unsigned long ccdMaxPasses);
    unsigned long getCCDMaxPasses();
    float getFrictionOffsetThreshold();
    void setFrictionType(PxFrictionTypeEnum frictionType);
    PxFrictionTypeEnum getFrictionType();

    // Visualization and Statistics
    void getSimulationStatistics([Ref] PxSimulationStatistics stats);

    // Scene Query
    PxPruningStructureTypeEnum getStaticStructure();
    PxPruningStructureTypeEnum getDynamicStructure();
    void flushQueryUpdates();
    PxBatchQuery createBatchQuery([Const, Ref] PxBatchQueryDesc desc);
    void setDynamicTreeRebuildRateHint(unsigned long dynamicTreeRebuildRateHint);
    unsigned long getDynamicTreeRebuildRateHint();
    void forceDynamicTreeRebuild(boolean rebuildStaticStructure, boolean rebuildDynamicStructure);
    void setSceneQueryUpdateMode(PxSceneQueryUpdateModeEnum updateMode);
    PxSceneQueryUpdateModeEnum getSceneQueryUpdateMode();
    void sceneQueriesUpdate(optional PxBaseTask completionTask, optional boolean controlSimulation);
    boolean checkQueries(optional boolean block);
    boolean fetchQueries(optional boolean block);
    boolean raycast([Const, Ref] PxVec3 origin, [Const, Ref] PxVec3 unitDir, float distance, [Ref] PxRaycastCallback hitCall,
                    [Ref] optional PxHitFlags hitFlags, [Const, Ref] optional PxQueryFilterData filterData);
    boolean sweep([Const, Ref] PxGeometry geometry, [Const, Ref] PxTransform pose, [Const, Ref] PxVec3 unitDir, float distance,
                    [Ref] PxSweepCallback hitCall, [Ref] optional PxHitFlags hitFlags, [Const, Ref] optional PxQueryFilterData filterData);
    boolean overlap([Const, Ref] PxGeometry geometry, [Const, Ref] PxTransform pose, [Ref] PxOverlapCallback hitCall,
                    [Const, Ref] optional PxQueryFilterData filterData);
    unsigned long getSceneQueryStaticTimestamp();

    // Broad-phase
    PxBroadPhaseTypeEnum getBroadPhaseType();
    boolean getBroadPhaseCaps([Ref] PxBroadPhaseCaps caps);
    unsigned long getNbBroadPhaseRegions();
    unsigned long getBroadPhaseRegions(PxBroadPhaseRegionInfo userBuffer, unsigned long bufferSize, optional unsigned long startIndex);
    unsigned long addBroadPhaseRegion([Const, Ref] PxBroadPhaseRegion region, optional boolean populateRegion);
    boolean removeBroadPhaseRegion(unsigned long handle);

    // Threads and Memory
    //PxTaskManager getTaskManager();
    void lockRead(optional DOMString file, optional unsigned long line);
    void unlockRead();
    void lockWrite(optional DOMString file, optional unsigned long line);
    void unlockWrite();
    void setNbContactDataBlocks(unsigned long numBlocks);
    unsigned long getNbContactDataBlocksUsed();
    unsigned long getMaxNbContactDataBlocksUsed();
    unsigned long getContactReportStreamBufferSize();
    void setSolverBatchSize(unsigned long solverBatchSize);
    unsigned long getSolverBatchSize();
    void setSolverArticulationBatchSize(unsigned long solverBatchSize);
    unsigned long getSolverArticulationBatchSize();

    // Basics
    void release();
    void setFlag(PxSceneFlagEnum flag, boolean value);
    [Value] PxSceneFlags getFlags();
    void setLimits([Const, Ref] PxSceneLimits limits);
    [Value] PxSceneLimits getLimits();
    [Ref] PxPhysics getPhysics();
    unsigned long getTimestamp();

    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxSceneDesc {
    void PxSceneDesc([Const, Ref] PxTolerancesScale scale);
    void setToDefault([Const, Ref] PxTolerancesScale scale);
    boolean isValid();

    [Value] attribute PxVec3 gravity;
    attribute PxSimulationEventCallback simulationEventCallback;
    // [Value] attribute PxContactModifyCallback contactModifyCallback;
    // [Value] attribute PxCCDContactModifyCallback ccdContactModifyCallback;
    [Const] attribute VoidPtr filterShaderData;
    attribute unsigned long filterShaderDataSize;
    [Value] attribute PxSimulationFilterShader filterShader;
    // [Value] attribute PxSimulationFilterCallback filterCallback;
    attribute PxPairFilteringModeEnum kineKineFilteringMode;
    attribute PxPairFilteringModeEnum staticKineFilteringMode;
    attribute PxBroadPhaseTypeEnum broadPhaseType;
    // [Value] PxBroadPhaseCallback broadPhaseCallback;
    [Value] attribute PxSceneLimits limits;
    attribute PxFrictionTypeEnum frictionType;
    attribute PxSolverTypeEnum solverType;
    attribute float bounceThresholdVelocity;
    attribute float frictionOffsetThreshold;
    attribute float ccdMaxSeparation;
    attribute float solverOffsetSlop;
    [Value] attribute PxSceneFlags flags;
    attribute PxCpuDispatcher cpuDispatcher;
    attribute PxCudaContextManager cudaContextManager;
    attribute PxPruningStructureTypeEnum staticStructure;
    attribute PxPruningStructureTypeEnum dynamicStructure;
    attribute unsigned long dynamicTreeRebuildRateHint;
    attribute PxSceneQueryUpdateModeEnum sceneQueryUpdateMode;
    attribute VoidPtr userData;
    attribute unsigned long solverBatchSize;
    attribute unsigned long solverArticulationBatchSize;
    attribute unsigned long nbContactDataBlocks;
    attribute float maxBiasCoefficient;
    attribute unsigned long contactReportStreamBufferSize;
    attribute unsigned long ccdMaxPasses;
    attribute float ccdThreshold;
    attribute float wakeCounterResetValue;
    [Value] attribute PxBounds3 sanityBounds;
    [Value] attribute PxgDynamicsMemoryConfig gpuDynamicsConfig;
    attribute unsigned long gpuMaxNumPartitions;
    attribute unsigned long gpuComputeVersion;
};

enum PxSceneFlagEnum {
    "PxSceneFlagEnum::eENABLE_ACTIVE_ACTORS",
    "PxSceneFlagEnum::eENABLE_CCD",
    "PxSceneFlagEnum::eDISABLE_CCD_RESWEEP",
    "PxSceneFlagEnum::eADAPTIVE_FORCE",
    "PxSceneFlagEnum::eENABLE_PCM",
    "PxSceneFlagEnum::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE",
    "PxSceneFlagEnum::eDISABLE_CONTACT_CACHE",
    "PxSceneFlagEnum::eREQUIRE_RW_LOCK",
    "PxSceneFlagEnum::eENABLE_STABILIZATION",
    "PxSceneFlagEnum::eENABLE_AVERAGE_POINT",
    "PxSceneFlagEnum::eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS",
    "PxSceneFlagEnum::eENABLE_GPU_DYNAMICS",
    "PxSceneFlagEnum::eENABLE_ENHANCED_DETERMINISM",
    "PxSceneFlagEnum::eENABLE_FRICTION_EVERY_ITERATION",
    "PxSceneFlagEnum::eMUTABLE_FLAGS"
};

[Prefix="physx::"]
interface PxSceneFlags {
    void PxSceneFlags(unsigned long flags);
    boolean isSet(PxSceneFlagEnum flag);
    void set(PxSceneFlagEnum flag);
    void clear(PxSceneFlagEnum flag);
};

enum PxSceneQueryUpdateModeEnum {
    "PxSceneQueryUpdateModeEnum::eBUILD_ENABLED_COMMIT_ENABLED",
    "PxSceneQueryUpdateModeEnum::eBUILD_ENABLED_COMMIT_DISABLED",
    "PxSceneQueryUpdateModeEnum::eBUILD_DISABLED_COMMIT_DISABLED"
};

[Prefix="physx::"]
interface PxSceneLimits {
    void PxSceneLimits();
    void setToDefault();
    boolean isValid();
    attribute unsigned long maxNbActors;
    attribute unsigned long maxNbBodies;
    attribute unsigned long maxNbStaticShapes;
    attribute unsigned long maxNbDynamicShapes;
    attribute unsigned long maxNbAggregates;
    attribute unsigned long maxNbConstraints;
    attribute unsigned long maxNbRegions;
    attribute unsigned long maxNbBroadPhaseOverlaps;
};

[Prefix="physx::", NoDelete]
interface PxShape {
    unsigned long getReferenceCount();
    void acquireReference();
    PxGeometryTypeEnum getGeometryType();
    void setGeometry([Const, Ref] PxGeometry geometry);
    [Value] PxGeometryHolder getGeometry();
    boolean getBoxGeometry([Ref] PxBoxGeometry geometry);
    boolean getSphereGeometry([Ref] PxSphereGeometry geometry);
    boolean getCapsuleGeometry([Ref] PxCapsuleGeometry geometry);
    boolean getPlaneGeometry([Ref] PxPlaneGeometry geometry);
    boolean getConvexMeshGeometry([Ref] PxConvexMeshGeometry geometry);
    boolean getTriangleMeshGeometry([Ref] PxTriangleMeshGeometry geometry);
    boolean getHeightFieldGeometry([Ref] PxHeightFieldGeometry geometry);
    PxRigidActor getActor();
    void setMaterials(PxMaterialPtr materials, unsigned short materialCount);
    unsigned short getNbMaterials();
    unsigned long getMaterials(PxMaterialPtr userBuffer, unsigned long bufferSize, unsigned long startIndex);
    PxMaterial getMaterialFromInternalFaceIndex(unsigned long faceIndex);
    void setContactOffset(float contactOffset);
    float getContactOffset();
    void setRestOffset(float restOffset);
    float getRestOffset();
    void setTorsionalPatchRadius(float radius);
    float getTorsionalPatchRadius();
    void setMinTorsionalPatchRadius(float radius);
    float getMinTorsionalPatchRadius();
    void setFlag(PxShapeFlagEnum flag, boolean value);
    void setFlags([Ref] PxShapeFlags inFlags);
    [Value] PxShapeFlags getFlags();
    boolean isExclusive();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    // Pose Manipulation
    void setLocalPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getLocalPose(); 
    // Collision Filtering
    void setSimulationFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getSimulationFilterData();
    void setQueryFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getQueryFilterData();
    attribute VoidPtr userData;
};
PxShape implements PxBase;

enum PxShapeFlagEnum {
    "PxShapeFlagEnum::eSIMULATION_SHAPE",
    "PxShapeFlagEnum::eSCENE_QUERY_SHAPE",
    "PxShapeFlagEnum::eTRIGGER_SHAPE",
    "PxShapeFlagEnum::eVISUALIZATION"
};

[Prefix="physx::"]
interface PxShapeFlags {
    void PxShapeFlags(octet flags);
    boolean isSet(PxShapeFlagEnum flag);
    void set(PxShapeFlagEnum flag);
    void clear(PxShapeFlagEnum flag);
};

[Prefix="physx::"]
interface PxSimulationEventCallback { };

interface SimpleSimulationEventCallback {
    void onConstraintBreak(PxConstraintInfo constraints, unsigned long count);
    void onWake(PxActorPtr actors, unsigned long count);
    void onSleep(PxActorPtr actors, unsigned long count);
    void onContact([Const, Ref] PxContactPairHeader pairHeader, [Const] PxContactPair pairs, unsigned long nbPairs);
    void onTrigger(PxTriggerPair pairs, unsigned long count);
};
SimpleSimulationEventCallback implements PxSimulationEventCallback;

[JSImplementation="SimpleSimulationEventCallback"]
interface JavaSimulationEventCallback {
    void JavaSimulationEventCallback();
    void onConstraintBreak(PxConstraintInfo constraints, unsigned long count);
    void onWake(PxActorPtr actors, unsigned long count);
    void onSleep(PxActorPtr actors, unsigned long count);
    void onContact([Const, Ref] PxContactPairHeader pairHeader, [Const] PxContactPair pairs, unsigned long nbPairs);
    void onTrigger(PxTriggerPair pairs, unsigned long count);
};

[Prefix="physx::"]
interface PxSimulationFilterShader { };

[Prefix="physx::"]
interface PxSimulationStatistics {
    attribute unsigned long nbActiveConstraints;
    attribute unsigned long nbActiveDynamicBodies;
    attribute unsigned long nbActiveKinematicBodies;
    attribute unsigned long nbStaticBodies;
    attribute unsigned long nbDynamicBodies;
    attribute unsigned long nbKinematicBodies;
    attribute unsigned long[] nbShapes;
    attribute unsigned long nbAggregates;
    attribute unsigned long nbArticulations;
    attribute unsigned long nbAxisSolverConstraints;
    attribute unsigned long compressedContactSize;
    attribute unsigned long requiredContactConstraintMemory;
    attribute unsigned long peakConstraintMemory;
    attribute unsigned long nbDiscreteContactPairsTotal;
    attribute unsigned long nbDiscreteContactPairsWithCacheHits;
    attribute unsigned long nbDiscreteContactPairsWithContacts;
    attribute unsigned long nbNewPairs;
    attribute unsigned long nbLostPairs;
    attribute unsigned long nbNewTouches;
    attribute unsigned long nbLostTouches;
    attribute unsigned long nbPartitions;
    attribute unsigned long nbBroadPhaseAdds;
    attribute unsigned long nbBroadPhaseRemoves;
    //attribute unsigned long[][] nbDiscreteContactPairs;
    //attribute unsigned long[][] nbCCDPairs;
    //attribute unsigned long[][] nbModifiedContactPairs;
    //attribute unsigned long[][] nbTriggerPairs;
};

enum PxSolverTypeEnum {
    "PxSolverTypeEnum::ePGS",
    "PxSolverTypeEnum::eTGS"
};

[Prefix="physx::"]
interface PxSpatialVelocity {
    [Value] attribute PxVec3 linear;
    [Value] attribute PxVec3 angular;
};

interface PxSweepBuffer10 {
    void PxSweepBuffer10();
    unsigned long getNbAnyHits();
    [Const, Ref] PxSweepHit getAnyHit(unsigned long index);
    unsigned long getNbTouches();
    [Const] PxSweepHit getTouches();
    [Const, Ref] PxSweepHit getTouch(unsigned long index);
    unsigned long getMaxNbTouches();
    [Value] attribute PxSweepHit block;
    attribute boolean hasBlock;
};
PxSweepBuffer10 implements PxSweepCallback;

[Prefix="physx::"]
interface PxSweepCallback {
    boolean hasAnyHits();
};

[Prefix="physx::"]
interface PxSweepHit { };
PxSweepHit implements PxLocationHit;

[Prefix="physx::"]
interface PxSweepQueryResult {
    unsigned long getNbAnyHits();
    [Const, Ref] PxSweepHit getAnyHit(unsigned long index);
    [Value] attribute PxSweepHit block;
    attribute PxSweepHit touches;
    attribute unsigned long nbTouches;
    attribute any userData; 
    attribute octet queryStatus;
    attribute boolean hasBlock;
};

[Prefix="physx::"]
interface PxTriggerPair {
    attribute PxShape triggerShape;
    attribute PxRigidActor triggerActor;
    attribute PxShape otherShape;
    attribute PxRigidActor otherActor;
    attribute PxPairFlagEnum status;
    [Value] attribute PxTriggerPairFlags flags;
};

enum PxTriggerPairFlagEnum {
    "PxTriggerPairFlagEnum::eREMOVED_SHAPE_TRIGGER",
    "PxTriggerPairFlagEnum::eREMOVED_SHAPE_OTHER",
    "PxTriggerPairFlagEnum::eNEXT_FREE"
};

[Prefix="physx::"]
interface PxTriggerPairFlags {
    void PxTriggerPairFlags(octet flags);
    boolean isSet(PxTriggerPairFlagEnum flag);
    void set(PxTriggerPairFlagEnum flag);
    void clear(PxTriggerPairFlagEnum flag);
};

/****************************************
 * [package=vehicle]
 ****************************************/

interface PxVehicleTopLevelFunctions {
    static boolean InitVehicleSDK([Ref] PxPhysics physics);
    static void PxVehicleComputeSprungMasses(unsigned long nbSprungMasses, [Const] PxVec3 sprungMassCoordinates, [Const, Ref] PxVec3 centreOfMass, float totalMass, unsigned long gravityDirection, [Ref] PxRealPtr sprungMasses);
    static void PxVehicleSuspensionRaycasts(PxBatchQuery batchQuery, [Ref] Vector_PxVehicleWheels vehicles, unsigned long nbSceneQueryResults, PxRaycastQueryResult sceneQueryResults);
    static void PxVehicleUpdates(float timestep, [Const, Ref] PxVec3 gravity, [Const, Ref] PxVehicleDrivableSurfaceToTireFrictionPairs vehicleDrivableSurfaceToTireFrictionPairs,
                                 [Ref] Vector_PxVehicleWheels vehicles, PxVehicleWheelQueryResult vehicleWheelQueryResults);
    static void VehicleSetBasisVectors([Const, Ref] PxVec3 up, [Const, Ref] PxVec3 forward);
    static void VehicleSetUpdateMode(PxVehicleUpdateModeEnum vehicleUpdateMode);

    static float PxVehicleTireData_getFrictionVsSlipGraph(PxVehicleTireData tireData, unsigned long m, unsigned long n);
    static void PxVehicleTireData_setFrictionVsSlipGraph(PxVehicleTireData tireData, unsigned long m, unsigned long n, float value);

    [Value] static PxBatchQueryPreFilterShader DefaultWheelSceneQueryPreFilterBlocking();
    [Value] static PxBatchQueryPostFilterShader DefaultWheelSceneQueryPostFilterBlocking();
};

[Prefix="physx::"]
interface PxVehicleAckermannGeometryData {
    void PxVehicleAckermannGeometryData();
    attribute float mAccuracy;
    attribute float mFrontWidth;
    attribute float mRearWidth;
    attribute float mAxleSeparation;
};

[Prefix="physx::"]
interface PxVehicleAntiRollBarData {
    void PxVehicleAntiRollBarData();
    attribute unsigned long mWheel0;
    attribute unsigned long mWheel1;
    attribute float mStiffness;
};

[Prefix="physx::"]
interface PxVehicleAutoBoxData {
    void PxVehicleAutoBoxData();
    void setLatency(float latency);
    float getLatency();
    float getUpRatios(PxVehicleGearEnum a);
    void setUpRatios(PxVehicleGearEnum a, float ratio);
    float getDownRatios(PxVehicleGearEnum a);
    void setDownRatios(PxVehicleGearEnum a, float ratio);

    attribute float[] mUpRatios;
    attribute float[] mDownRatios;
};

[Prefix="physx::"]
interface PxVehicleChassisData {
    void PxVehicleChassisData();
    [Value] attribute PxVec3 mMOI;
    attribute float mMass;
    [Value] attribute PxVec3 mCMOffset;
};

enum PxVehicleClutchAccuracyModeEnum {
    "PxVehicleClutchAccuracyModeEnum::eESTIMATE",
    "PxVehicleClutchAccuracyModeEnum::eBEST_POSSIBLE"
};

[Prefix="physx::"]
interface PxVehicleClutchData {
    void PxVehicleClutchData();
    attribute float mStrength;
    attribute PxVehicleClutchAccuracyModeEnum mAccuracyMode;
    attribute unsigned long mEstimateIterations;
};

[Prefix="physx::"]
interface PxVehicleDifferential4WData {
    void PxVehicleDifferential4WData();
    attribute float mFrontRearSplit;
    attribute float mFrontLeftRightSplit;
    attribute float mRearLeftRightSplit;
    attribute float mCentreBias;
    attribute float mFrontBias;
    attribute float mRearBias;
    attribute PxVehicleDifferential4WDataEnum mType;
};

enum PxVehicleDifferential4WDataEnum {
    "PxVehicleDifferential4WDataEnum::eDIFF_TYPE_LS_4WD",
    "PxVehicleDifferential4WDataEnum::eDIFF_TYPE_LS_FRONTWD",
    "PxVehicleDifferential4WDataEnum::eDIFF_TYPE_LS_REARWD",
    "PxVehicleDifferential4WDataEnum::eDIFF_TYPE_OPEN_4WD",
    "PxVehicleDifferential4WDataEnum::eDIFF_TYPE_OPEN_FRONTWD",
    "PxVehicleDifferential4WDataEnum::eDIFF_TYPE_OPEN_REARWD",
    "PxVehicleDifferential4WDataEnum::eMAX_NB_DIFF_TYPES"
};

[Prefix="physx::"]
interface PxVehicleDifferentialNWData {
    void PxVehicleDifferentialNWData();
    void setDrivenWheel(unsigned long wheelId, boolean drivenState);
    boolean getIsDrivenWheel(unsigned long wheelId);
    unsigned long getDrivenWheelStatus();
    void setDrivenWheelStatus(unsigned long status);
};

[Prefix="physx::", NoDelete]
interface PxVehicleDrivableSurfaceToTireFrictionPairs {
    static PxVehicleDrivableSurfaceToTireFrictionPairs allocate(unsigned long maxNbTireTypes, unsigned long maxNbSurfaceTypes);
    void setup(unsigned long nbTireTypes, unsigned long nbSurfaceTypes, PxMaterialConstPtr drivableSurfaceMaterials, [Const] PxVehicleDrivableSurfaceType drivableSurfaceTypes);
    void release();
    void setTypePairFriction(unsigned long surfaceType, unsigned long tireType, float value);
    float getTypePairFriction(unsigned long surfaceType, unsigned long tireType);
    unsigned long getMaxNbSurfaceTypes();
    unsigned long getMaxNbTireTypes();
};

[Prefix="physx::"]
interface PxVehicleDrivableSurfaceType {
    void PxVehicleDrivableSurfaceType();
    attribute unsigned long mType;
};

[Prefix="physx::", NoDelete]
interface PxVehicleDrive {
    [Value] attribute PxVehicleDriveDynData mDriveDynData;
};
PxVehicleDrive implements PxVehicleWheels;

[Prefix="physx::", NoDelete]
interface PxVehicleDrive4W {
    static PxVehicleDrive4W allocate(unsigned long nbWheels);
    //void PxVehicleDrive4W([Ref] PxBaseFlags baseFlags);
    void free();
    void setup(PxPhysics physics, PxRigidDynamic vehActor, [Const, Ref] PxVehicleWheelsSimData wheelsData, [Const, Ref] PxVehicleDriveSimData4W driveData, unsigned long nbNonDrivenWheels);
    void setToRestState();
    [Value] attribute PxVehicleDriveSimData4W mDriveSimData;
};
PxVehicleDrive4W implements PxVehicleDrive;

enum PxVehicleDrive4WControlEnum {
    "PxVehicleDrive4WControlEnum::eANALOG_INPUT_ACCEL",
    "PxVehicleDrive4WControlEnum::eANALOG_INPUT_BRAKE",
    "PxVehicleDrive4WControlEnum::eANALOG_INPUT_HANDBRAKE",
    "PxVehicleDrive4WControlEnum::eANALOG_INPUT_STEER_LEFT",
    "PxVehicleDrive4WControlEnum::eANALOG_INPUT_STEER_RIGHT",
    "PxVehicleDrive4WControlEnum::eMAX_NB_DRIVE4W_ANALOG_INPUTS"
};

[Prefix="physx::"]
interface PxVehicleDriveDynData {
    void setToRestState();
    void setAnalogInput(unsigned long type, float analogVal);
    float getAnalogInput(unsigned long type);
    void setGearUp(boolean digitalVal);
    void setGearDown(boolean digitalVal);
    boolean getGearUp();
    boolean getGearDown();
    void setUseAutoGears(boolean useAutoGears);
    boolean getUseAutoGears();
    void toggleAutoGears();
    void setCurrentGear(unsigned long currentGear);
    unsigned long getCurrentGear();
    void setTargetGear(unsigned long targetGear);
    unsigned long getTargetGear();
    void startGearChange(unsigned long targetGear);
    void forceGearChange(unsigned long targetGear);
    void setEngineRotationSpeed(float speed);
    float getEngineRotationSpeed();
    float getGearSwitchTime();
    float getAutoBoxSwitchTime();
    unsigned long getNbAnalogInput();
    void setGearChange(unsigned long gearChange);
    unsigned long getGearChange();
    void setGearSwitchTime(float switchTime);
    void setAutoBoxSwitchTime(float autoBoxSwitchTime);

    attribute float[] mControlAnalogVals;
    attribute boolean mUseAutoGears;
    attribute boolean mGearUpPressed;
    attribute boolean mGearDownPressed;
    attribute unsigned long mCurrentGear;
    attribute unsigned long mTargetGear;
    attribute float mEnginespeed;
    attribute float mGearSwitchTime;
    attribute float mAutoBoxSwitchTime;
};

[Prefix="physx::", NoDelete]
interface PxVehicleDriveNW {
    static PxVehicleDriveNW allocate(unsigned long nbWheels);
    void free();
    void setup(PxPhysics physics, PxRigidDynamic vehActor, [Const, Ref] PxVehicleWheelsSimData wheelsData, [Const, Ref] PxVehicleDriveSimDataNW driveData, unsigned long nbWheels);
    void setToRestState();
    [Value] attribute PxVehicleDriveSimDataNW mDriveSimData;
};
PxVehicleDriveNW implements PxVehicleDrive;

[Prefix="physx::"]
interface PxVehicleDriveSimData {
    void PxVehicleDriveSimData();
    [Const, Ref] PxVehicleEngineData getEngineData();
    void setEngineData([Const, Ref] PxVehicleEngineData engine);
    [Const, Ref] PxVehicleGearsData getGearsData();
    void setGearsData([Const, Ref] PxVehicleGearsData gears);
    [Const, Ref] PxVehicleClutchData getClutchData();
    void setClutchData([Const, Ref] PxVehicleClutchData clutch);
    [Const, Ref] PxVehicleAutoBoxData getAutoBoxData();
    void setAutoBoxData([Const, Ref] PxVehicleAutoBoxData clutch);
};

[Prefix="physx::"]
interface PxVehicleDriveSimData4W {
    void PxVehicleDriveSimData4W();
    [Const, Ref] PxVehicleDifferential4WData getDiffData();
    [Const, Ref] PxVehicleAckermannGeometryData getAckermannGeometryData();
    void setDiffData([Const, Ref] PxVehicleDifferential4WData diff);
    void setAckermannGeometryData([Const, Ref] PxVehicleAckermannGeometryData ackermannData);
};
PxVehicleDriveSimData4W implements PxVehicleDriveSimData;

[Prefix="physx::"]
interface PxVehicleDriveSimDataNW {
    void PxVehicleDriveSimDataNW();
    [Const, Ref] PxVehicleDifferentialNWData getDiffData();
    void setDiffData([Const, Ref] PxVehicleDifferentialNWData diff);
};
PxVehicleDriveSimDataNW implements PxVehicleDriveSimData;

[Prefix="physx::", NoDelete]
interface PxVehicleDriveTank {
    static PxVehicleDriveTank allocate(unsigned long nbWheels);
    void free();
    void setup(PxPhysics physics, PxRigidDynamic vehActor, [Const, Ref] PxVehicleWheelsSimData wheelsData, [Const, Ref] PxVehicleDriveSimData driveData, unsigned long nbDrivenWheels);
    void setDriveModel(PxVehicleDriveTankControlModelEnum driveModel);
    PxVehicleDriveTankControlModelEnum getDriveModel();
    void setToRestState();
    [Value] attribute PxVehicleDriveSimData mDriveSimData;
};
PxVehicleDriveTank implements PxVehicleDrive;

enum PxVehicleDriveTankControlModelEnum {
    "PxVehicleDriveTankControlModelEnum::eSTANDARD",
    "PxVehicleDriveTankControlModelEnum::eSPECIAL"
};

[Prefix="physx::"]
interface PxVehicleEngineData {
    void PxVehicleEngineData();

    [Value] attribute PxEngineTorqueLookupTable mTorqueCurve;
    attribute float mMOI;
    attribute float mPeakTorque;
    attribute float mMaxOmega;
    attribute float mDampingRateFullThrottle;
    attribute float mDampingRateZeroThrottleClutchEngaged;
    attribute float mDampingRateZeroThrottleClutchDisengaged;
};

interface PxEngineTorqueLookupTable {
    void PxEngineTorqueLookupTable();
    void addPair(float x, float y);
    float getYVal(float x);
    unsigned long getNbDataPairs();
    void clear();
    float getX(unsigned long i);
    float getY(unsigned long i);

    attribute float[] mDataPairs;
    attribute unsigned long mNbDataPairs;
};

[Prefix="physx::"]
interface PxVehicleGearsData {
    void PxVehicleGearsData();
    float getGearRatio(PxVehicleGearEnum a);
    void setGearRatio(PxVehicleGearEnum a, float ratio);

    attribute float[] mRatios;
    attribute float mFinalRatio;
    attribute unsigned long mNbRatios;
    attribute float mSwitchTime;
};

enum PxVehicleGearEnum {
    "PxVehicleGearEnum::eREVERSE",
    "PxVehicleGearEnum::eNEUTRAL",
    "PxVehicleGearEnum::eFIRST",
    "PxVehicleGearEnum::eSECOND",
    "PxVehicleGearEnum::eTHIRD",
    "PxVehicleGearEnum::eFOURTH",
    "PxVehicleGearEnum::eFIFTH",
    "PxVehicleGearEnum::eSIXTH",
    "PxVehicleGearEnum::eSEVENTH",
    "PxVehicleGearEnum::eEIGHTH",
    "PxVehicleGearEnum::eNINTH",
    "PxVehicleGearEnum::eTENTH",
    "PxVehicleGearEnum::eELEVENTH",
    "PxVehicleGearEnum::eTWELFTH",
    "PxVehicleGearEnum::eTHIRTEENTH",
    "PxVehicleGearEnum::eFOURTEENTH",
    "PxVehicleGearEnum::eFIFTEENTH",
    "PxVehicleGearEnum::eSIXTEENTH",
    "PxVehicleGearEnum::eSEVENTEENTH",
    "PxVehicleGearEnum::eEIGHTEENTH",
    "PxVehicleGearEnum::eNINETEENTH",
    "PxVehicleGearEnum::eTWENTIETH",
    "PxVehicleGearEnum::eTWENTYFIRST",
    "PxVehicleGearEnum::eTWENTYSECOND",
    "PxVehicleGearEnum::eTWENTYTHIRD",
    "PxVehicleGearEnum::eTWENTYFOURTH",
    "PxVehicleGearEnum::eTWENTYFIFTH",
    "PxVehicleGearEnum::eTWENTYSIXTH",
    "PxVehicleGearEnum::eTWENTYSEVENTH",
    "PxVehicleGearEnum::eTWENTYEIGHTH",
    "PxVehicleGearEnum::eTWENTYNINTH",
    "PxVehicleGearEnum::eTHIRTIETH",
    "PxVehicleGearEnum::eGEARSRATIO_COUNT"
};

[Prefix="physx::", NoDelete]
interface PxVehicleNoDrive {
    static PxVehicleNoDrive allocate(unsigned long nbWheels);
    void free();
    void setup(PxPhysics physics, PxRigidDynamic vehActor, [Const, Ref] PxVehicleWheelsSimData wheelsData);
    void setToRestState();
    void setBrakeTorque(unsigned long id, float brakeTorque);
    void setDriveTorque(unsigned long id, float driveTorque);
    void setSteerAngle(unsigned long id, float steerAngle);
    float getBrakeTorque(unsigned long id);
    float getDriveTorque(unsigned long id);
    float getSteerAngle(unsigned long id);
    unsigned long getNbSteerAngle();
    unsigned long getNbDriveTorque();
    unsigned long getNbBrakeTorque();
};
PxVehicleNoDrive implements PxVehicleWheels;

[Prefix="physx::"]
interface PxVehicleSuspensionData {
    void PxVehicleSuspensionData();
    void setMassAndPreserveNaturalFrequency(float newSprungMass);
    attribute float mSpringStrength;
    attribute float mSpringDamperRate;
    attribute float mMaxCompression;
    attribute float mMaxDroop;
    attribute float mSprungMass;
    attribute float mCamberAtRest;
    attribute float mCamberAtMaxCompression;
    attribute float mCamberAtMaxDroop;
};

[Prefix="physx::"]
interface PxVehicleTireData {
    void PxVehicleTireData();
    attribute float mLatStiffX;
    attribute float mLatStiffY;
    attribute float mLongitudinalStiffnessPerUnitGravity;
    attribute float mCamberStiffnessPerUnitGravity;
    //attribute float[][] mFrictionVsSlipGraph;     // 2-dimensional array is not supported by WebIDL
    attribute unsigned long mType;
};

[Prefix="physx::"]
interface PxVehicleTireLoadFilterData {
    void PxVehicleTireLoadFilterData();
    float getDenominator();
    attribute float mMinNormalisedLoad;
    attribute float mMinFilteredNormalisedLoad;
    attribute float mMaxNormalisedLoad;
    attribute float mMaxFilteredNormalisedLoad;
};

enum PxVehicleUpdateModeEnum {
    "PxVehicleUpdateModeEnum::eVELOCITY_CHANGE",
    "PxVehicleUpdateModeEnum::eACCELERATION"
};

[Prefix="physx::"]
interface PxVehicleWheelData {
    void PxVehicleWheelData();
    attribute float mRadius;
    attribute float mWidth;
    attribute float mMass;
    attribute float mMOI;
    attribute float mDampingRate;
    attribute float mMaxBrakeTorque;
    attribute float mMaxHandBrakeTorque;
    attribute float mMaxSteer;
    attribute float mToeAngle;
};

[Prefix="physx::"]
interface PxVehicleWheelQueryResult {
    void PxVehicleWheelQueryResult();
    attribute PxWheelQueryResult wheelQueryResults;
    attribute unsigned long nbWheelQueryResults;
};

[Prefix="physx::", NoDelete]
interface PxVehicleWheels {
    unsigned long getVehicleType();
    PxRigidDynamic getRigidDynamicActor();
    float computeForwardSpeed();
    float computeSidewaysSpeed();
    unsigned long getNbNonDrivenWheels();

    [Value] attribute PxVehicleWheelsSimData mWheelsSimData;
    [Value] attribute PxVehicleWheelsDynData mWheelsDynData;
};
PxVehicleWheels implements PxBase;

[Prefix="physx::"]
interface PxVehicleWheelsDynData {
    void setToRestState();
    //void setTireForceShaderFunction(PxVehicleComputeTireForce tireForceShaderFn);
    //void setTireForceShaderData(unsigned long tireId, [Const] any tireForceShaderData);
    //[Const] any getTireForceShaderData(unsigned long tireId);
    void setWheelRotationSpeed(unsigned long wheelIdx, float speed);
    float getWheelRotationSpeed(unsigned long wheelIdx);
    void setWheelRotationAngle(unsigned long wheelIdx, float angle);
    float getWheelRotationAngle(unsigned long wheelIdx);
    //void setUserData(unsigned long tireIdx, any userData);
    //any getUserData(unsigned long tireIdx);
    void copy([Const, Ref] PxVehicleWheelsDynData src, unsigned long srcWheel, unsigned long trgWheel);
    unsigned long getNbWheelRotationSpeed();
    unsigned long getNbWheelRotationAngle();
};

[Prefix="physx::"]
interface PxVehicleWheelsSimData {
    static PxVehicleWheelsSimData allocate(unsigned long nbWheels);

    void setChassisMass(float chassisMass);
    void free();
    void copy([Const, Ref] PxVehicleWheelsSimData src, unsigned long srcWheel, unsigned long trgWheel);
    unsigned long getNbWheels();
    
    [Const, Ref] PxVehicleSuspensionData getSuspensionData(unsigned long id);
    [Const, Ref] PxVehicleWheelData getWheelData(unsigned long id);
    [Const, Ref] PxVehicleTireData getTireData(unsigned long id);
    [Const, Ref] PxVec3 getSuspTravelDirection(unsigned long id);
    [Const, Ref] PxVec3 getSuspForceAppPointOffset(unsigned long id);
    [Const, Ref] PxVec3 getTireForceAppPointOffset(unsigned long id);
    [Const, Ref] PxVec3 getWheelCentreOffset(unsigned long id);
    long getWheelShapeMapping(unsigned long wheelId);
    [Const, Ref] PxFilterData getSceneQueryFilterData(unsigned long suspId);
    unsigned long getNbAntiRollBars();
    [Const, Ref] PxVehicleAntiRollBarData getAntiRollBarData(unsigned long antiRollId);
    [Const, Ref] PxVehicleTireLoadFilterData getTireLoadFilterData();
    
    void setSuspensionData(unsigned long id, [Const, Ref] PxVehicleSuspensionData susp);
    void setWheelData(unsigned long id, [Const, Ref] PxVehicleWheelData wheel);
    void setTireData(unsigned long id, [Const, Ref] PxVehicleTireData tire);
    void setSuspTravelDirection(unsigned long id, [Const, Ref] PxVec3 dir);
    void setSuspForceAppPointOffset(unsigned long id, [Const, Ref] PxVec3 offset);
    void setTireForceAppPointOffset(unsigned long id, [Const, Ref] PxVec3 offset);
    void setWheelCentreOffset(unsigned long id, [Const, Ref] PxVec3 offset);
    void setWheelShapeMapping(unsigned long wheelId, long shapeId);
    void setSceneQueryFilterData(unsigned long suspId, [Const, Ref] PxFilterData sqFilterData);
    void setTireLoadFilterData([Const, Ref] PxVehicleTireLoadFilterData tireLoadFilter);
    unsigned long addAntiRollBarData([Const, Ref] PxVehicleAntiRollBarData antiRoll);

    void disableWheel(unsigned long wheel);
    void enableWheel(unsigned long wheel);
    boolean getIsWheelDisabled(unsigned long wheel);
    void setSubStepCount(float thresholdLongitudinalSpeed, unsigned long lowForwardSpeedSubStepCount, unsigned long highForwardSpeedSubStepCount);
    void setMinLongSlipDenominator(float minLongSlipDenominator);
    void setFlags([Ref] PxVehicleWheelsSimFlags flags);
    [Value] PxVehicleWheelsSimFlags getFlags();

    unsigned long getNbWheels4();
    unsigned long getNbSuspensionData();
    unsigned long getNbWheelData();
    unsigned long getNbSuspTravelDirection();
    unsigned long getNbTireData();
    unsigned long getNbSuspForceAppPointOffset();
    unsigned long getNbTireForceAppPointOffset();
    unsigned long getNbWheelCentreOffset();
    unsigned long getNbWheelShapeMapping();
    unsigned long getNbSceneQueryFilterData();
    float getMinLongSlipDenominator();
    void setThresholdLongSpeed(float f);
    float getThresholdLongSpeed();
    void setLowForwardSpeedSubStepCount(unsigned long f);
    unsigned long getLowForwardSpeedSubStepCount();
    void setHighForwardSpeedSubStepCount(unsigned long f);
    unsigned long getHighForwardSpeedSubStepCount();
    void setWheelEnabledState(unsigned long wheel, boolean state);
    boolean getWheelEnabledState(unsigned long wheel);
    unsigned long getNbWheelEnabledState();
    unsigned long getNbAntiRollBars4();
    unsigned long getNbAntiRollBarData();
    void setAntiRollBarData(unsigned long id, [Const, Ref] PxVehicleAntiRollBarData antiRoll);
};

enum PxVehicleWheelsSimFlagEnum {
    "PxVehicleWheelsSimFlagEnum::eLIMIT_SUSPENSION_EXPANSION_VELOCITY"
};

[Prefix="physx::"]
interface PxVehicleWheelsSimFlags {
    void PxVehicleWheelsSimFlags(unsigned long flags);
    boolean isSet(PxVehicleWheelsSimFlagEnum flag);
    void set(PxVehicleWheelsSimFlagEnum flag);
    void clear(PxVehicleWheelsSimFlagEnum flag);
};

[Prefix="physx::"]
interface PxWheelQueryResult {
    void PxWheelQueryResult();
    [Value] attribute PxVec3 suspLineStart;
    [Value] attribute PxVec3 suspLineDir;
    attribute float suspLineLength;
    attribute boolean isInAir;
    attribute PxActor tireContactActor;
    attribute PxShape tireContactShape;
    [Const] attribute PxMaterial tireSurfaceMaterial;
    attribute unsigned long tireSurfaceType;
    [Value] attribute PxVec3 tireContactPoint;
    [Value] attribute PxVec3 tireContactNormal;
    attribute float tireFriction;
    attribute float suspJounce;
    attribute float suspSpringForce;
    [Value] attribute PxVec3 tireLongitudinalDir;
    [Value] attribute PxVec3 tireLateralDir;
    attribute float longitudinalSlip;
    attribute float lateralSlip;
    attribute float steerAngle;
    [Value] attribute PxTransform localPose;
};

enum VehicleSurfaceTypeMask {
    "DRIVABLE_SURFACE",
    "UNDRIVABLE_SURFACE",
};

/****************************************
 * [package=geomutils]
 ****************************************/

[Prefix="physx::"]
interface PxBoxGeometry {
    void PxBoxGeometry(float hx, float hy, float hz);
};
PxBoxGeometry implements PxGeometry;

[Prefix="physx::", NoDelete]
interface PxBVHStructure { };
PxBVHStructure implements PxBase;

[Prefix="physx::"]
interface PxCapsuleGeometry {
    void PxCapsuleGeometry(float radius, float halfHeight);
};
PxCapsuleGeometry implements PxGeometry;

[Prefix="physx::", NoDelete]
interface PxConvexMesh {
    unsigned long getNbVertices();
    [Const] PxVec3 getVertices();
    [Value] PxU8ConstPtr getIndexBuffer();
    unsigned long getNbPolygons();
    boolean getPolygonData(unsigned long index, [Ref] PxHullPolygon data);
    unsigned long getReferenceCount();
    void acquireReference();
    [Value] PxBounds3 getLocalBounds();
    boolean isGpuCompatible();
};
PxConvexMesh implements PxBase;

[Prefix="physx::"]
interface PxConvexMeshGeometry {
    void PxConvexMeshGeometry(PxConvexMesh mesh, [Const, Ref] optional PxMeshScale scaling, [Ref] optional PxConvexMeshGeometryFlags flags);
};
PxConvexMeshGeometry implements PxGeometry;

enum PxConvexMeshGeometryFlagEnum {
    "PxConvexMeshGeometryFlagEnum::eTIGHT_BOUNDS"
};

[Prefix="physx::"]
interface PxConvexMeshGeometryFlags {
    void PxConvexMeshGeometryFlags(octet flags);
    boolean isSet(PxConvexMeshGeometryFlagEnum flag);
    void set(PxConvexMeshGeometryFlagEnum flag);
    void clear(PxConvexMeshGeometryFlagEnum flag);
};

[Prefix="physx::"]
interface PxGeometry {
    PxGeometryTypeEnum getType();
};

[Prefix="physx::"]
interface PxGeometryHolder {
    void PxGeometryHolder();
    void PxGeometryHolder([Const, Ref] PxGeometry geometry);
    PxGeometryTypeEnum getType();
    //[Ref] PxGeometry any();       // does not work: any is a keyword
    [Ref] PxSphereGeometry sphere();
    [Ref] PxPlaneGeometry plane();
    [Ref] PxCapsuleGeometry capsule();
    [Ref] PxBoxGeometry box();
    [Ref] PxConvexMeshGeometry convexMesh();
    [Ref] PxTriangleMeshGeometry triangleMesh();
    [Ref] PxHeightFieldGeometry heightField();
    void storeAny([Const, Ref] PxGeometry geometry);
};

[Prefix="physx::"]
interface PxGeometryQuery {
    static boolean sweep([Const, Ref] PxVec3 unitDir, float maxDist, [Const, Ref] PxGeometry geom0, [Const, Ref] PxTransform pose0,
                         [Const, Ref] PxGeometry geom1, [Const, Ref] PxTransform pose1, [Ref] PxSweepHit sweepHit,
                         [Ref] optional PxHitFlags hitFlags, optional float inflation);
    static boolean overlap([Const, Ref] PxGeometry geom0, [Const, Ref] PxTransform pose0,
                           [Const, Ref] PxGeometry geom1, [Const, Ref] PxTransform pose1);
    static unsigned long raycast([Const, Ref] PxVec3 origin, [Const, Ref] PxVec3 unitDir, [Const, Ref] PxGeometry geom,
                           [Const, Ref] PxTransform pose, float maxDist, [Ref] PxHitFlags hitFlags,
                           unsigned long maxHits, PxRaycastHit rayHits);
//    static boolean computePenetration([Ref] PxVec3 direction, [Ref] float depth, [Const, Ref] PxGeometry geom0,
//                        [Const, Ref] PxTransform pose0, [Const, Ref] PxGeometry geom1, [Const, Ref] PxTransform pose1);
    static float pointDistance([Const, Ref] PxVec3 point, [Const, Ref] PxGeometry geom, [Const, Ref] PxTransform pose, optional PxVec3 closestPoint);
    [Value] static PxBounds3 getWorldBounds([Const, Ref] PxGeometry geom, [Const, Ref] PxTransform pose, optional float inflation);
    static boolean isValid([Const, Ref] PxGeometry geom);
};

enum PxGeometryTypeEnum {
    "PxGeometryTypeEnum::eSPHERE",
    "PxGeometryTypeEnum::ePLANE",
    "PxGeometryTypeEnum::eCAPSULE",
    "PxGeometryTypeEnum::eBOX",
    "PxGeometryTypeEnum::eCONVEXMESH",
    "PxGeometryTypeEnum::eTRIANGLEMESH",
    "PxGeometryTypeEnum::eHEIGHTFIELD"
};

[Prefix="physx::", NoDelete]
interface PxHeightField {
    unsigned long saveCells(VoidPtr destBuffer, unsigned long destBufferSize);
    boolean modifySamples(long startCol, long startRow, [Const, Ref] PxHeightFieldDesc subfieldDesc, optional boolean shrinkBounds);
    unsigned long getNbRows();
    unsigned long getNbColumns();
    PxHeightFieldFormatEnum getFormat();
    unsigned long getSampleStride();
    float getConvexEdgeThreshold();
    [Value] PxHeightFieldFlags getFlags();
    float getHeight(float x, float z);
    unsigned long getReferenceCount();
    void acquireReference();
    unsigned short getTriangleMaterialIndex(unsigned long triangleIndex);
    [Value] PxVec3 getTriangleNormal(unsigned long triangleIndex);
    [Const, Ref] PxHeightFieldSample getSample(unsigned long row, unsigned long column);
    unsigned long getTimestamp();
};
PxHeightField implements PxBase;

[Prefix="physx::"]
interface PxHeightFieldDesc {
    void PxHeightFieldDesc();
    void setToDefault();
    boolean isValid();
    attribute unsigned long nbRows;
    attribute unsigned long nbColumns;
    attribute PxHeightFieldFormatEnum format;
    [Value] attribute PxStridedData samples;
    attribute float convexEdgeThreshold;
    [Value] attribute PxHeightFieldFlags flags;
};

[Prefix="physx::"]
interface PxHeightFieldFlags {
    void PxHeightFieldFlags(unsigned short flags);
    boolean isSet(PxHeightFieldFlagEnum flag);
    void set(PxHeightFieldFlagEnum flag);
    void clear(PxHeightFieldFlagEnum flag);
};

enum PxHeightFieldFlagEnum {
    "PxHeightFieldFlagEnum::eNO_BOUNDARY_EDGES"
};

enum PxHeightFieldFormatEnum {
    "PxHeightFieldFormatEnum::eS16_TM"
};

[Prefix="physx::"]
interface PxHeightFieldGeometry {
    void PxHeightFieldGeometry();
    void PxHeightFieldGeometry(PxHeightField hf, [Ref] PxMeshGeometryFlags flags, float heightScale, float rowScale, float columnScale);
    boolean isValid();
    attribute PxHeightField heightField;
    attribute float heightScale;
    attribute float rowScale;
    attribute float columnScale;
    [Value] attribute PxMeshGeometryFlags heightFieldFlags;
};
PxHeightFieldGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxHeightFieldSample {
    attribute short height;
    attribute octet materialIndex0;
    attribute octet materialIndex1;
};

[Prefix="physx::"]
interface PxHullPolygon {
    void PxHullPolygon();
    attribute float[] mPlane;
    attribute short mNbVerts;
    attribute short mIndexBase;
};

enum PxMeshFlagEnum {
    "PxMeshFlagEnum::eFLIPNORMALS",
    "PxMeshFlagEnum::e16_BIT_INDICES"
};

[Prefix="physx::"]
interface PxMeshFlags {
    void PxMeshFlags(octet flags);
    boolean isSet(PxMeshFlagEnum flag);
    void set(PxMeshFlagEnum flag);
    void clear(PxMeshFlagEnum flag);
};

enum PxMeshGeometryFlagEnum {
    "PxMeshGeometryFlagEnum::eDOUBLE_SIDED"
};

[Prefix="physx::"]
interface PxMeshGeometryFlags {
    void PxMeshGeometryFlags(octet flags);
    boolean isSet(PxMeshGeometryFlagEnum flag);
    void set(PxMeshGeometryFlagEnum flag);
    void clear(PxMeshGeometryFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshScale {
    void PxMeshScale();
    void PxMeshScale(float r);
    void PxMeshScale([Const, Ref] PxVec3 s, [Const, Ref] PxQuat r);
};

[Prefix="physx::"]
interface PxPlaneGeometry {
    void PxPlaneGeometry();
};
PxPlaneGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxSimpleTriangleMesh {
    void PxSimpleTriangleMesh();
    void setToDefault();
    boolean isValid();
    [Value] attribute PxBoundedData points;
    [Value] attribute PxBoundedData triangles;
    [Value] attribute PxMeshFlags flags;
};

[Prefix="physx::"]
interface PxSphereGeometry {
    void PxSphereGeometry(float ir);
};
PxSphereGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxTriangle {
    void PxTriangle();
    void PxTriangle([Const, Ref] PxVec3 p0, [Const, Ref] PxVec3 p1, [Const, Ref] PxVec3 p2);
    void normal([Ref] PxVec3 normal);
    void denormalizedNormal([Ref] PxVec3 normal);
    float area();
    [Value] PxVec3 pointFromUV(float u, float v);
};

[Prefix="physx::", NoDelete]
interface PxTriangleMesh {
    unsigned long getNbVertices();
    [Const] PxVec3 getVertices();
    PxVec3 getVerticesForModification();
    [Value] PxBounds3 refitBVH();
    unsigned long getNbTriangles();
    [Const] VoidPtr getTriangles();
    [Value] PxTriangleMeshFlags getTriangleMeshFlags();
    [Const, Value] PxU32ConstPtr getTrianglesRemap();
    unsigned short getTriangleMaterialIndex(unsigned long triangleIndex);
    [Value] PxBounds3 getLocalBounds();
    unsigned long getReferenceCount();
    void acquireReference();

};
PxTriangleMesh implements PxBase;

enum PxTriangleMeshFlagEnum {
    "PxTriangleMeshFlagEnum::e16_BIT_INDICES",
    "PxTriangleMeshFlagEnum::eADJACENCY_INFO"
};

[Prefix="physx::"]
interface PxTriangleMeshFlags {
    void PxTriangleMeshFlags(octet flags);
    boolean isSet(PxTriangleMeshFlagEnum flag);
    void set(PxTriangleMeshFlagEnum flag);
    void clear(PxTriangleMeshFlagEnum flag);
};

[Prefix="physx::"]
interface PxTriangleMeshGeometry {
    void PxTriangleMeshGeometry(PxTriangleMesh mesh, [Const, Ref] optional PxMeshScale scaling, [Ref] optional PxMeshGeometryFlags flags);
    boolean isValid();
};
PxTriangleMeshGeometry implements PxGeometry;

/****************************************
 * [package=cooking]
 ****************************************/

[Prefix="physx::"]
interface PxBVH33MidphaseDesc {
    void setToDefault();
    boolean isValid();

    attribute float meshSizePerformanceTradeOff;
    attribute PxMeshCookingHintEnum meshCookingHint;
};

[Prefix="physx::"]
interface PxBVH34MidphaseDesc {
    void setToDefault();
    boolean isValid();

    attribute unsigned long numPrimsPerLeaf;
};

enum PxConvexFlagEnum {
    "PxConvexFlagEnum::e16_BIT_INDICES",
    "PxConvexFlagEnum::eCOMPUTE_CONVEX",
    "PxConvexFlagEnum::eCHECK_ZERO_AREA_TRIANGLES",
    "PxConvexFlagEnum::eQUANTIZE_INPUT",
    "PxConvexFlagEnum::eDISABLE_MESH_VALIDATION",
    "PxConvexFlagEnum::ePLANE_SHIFTING",
    "PxConvexFlagEnum::eFAST_INERTIA_COMPUTATION",
    "PxConvexFlagEnum::eGPU_COMPATIBLE",
    "PxConvexFlagEnum::eSHIFT_VERTICES"
};

[Prefix="physx::"]
interface PxConvexFlags {
    void PxConvexFlags(unsigned short flags);
    boolean isSet(PxConvexFlagEnum flag);
    void set(PxConvexFlagEnum flag);
    void clear(PxConvexFlagEnum flag);
};

[Prefix="physx::"]
interface PxConvexMeshDesc {
    void PxConvexMeshDesc();
    [Value] attribute PxBoundedData points;
    [Value] attribute PxConvexFlags flags;
};

enum PxConvexMeshCookingTypeEnum {
    "PxConvexMeshCookingTypeEnum::eQUICKHULL"
};

[Prefix="physx::", NoDelete]
interface PxCooking {
    void release();
    PxConvexMesh createConvexMesh([Const, Ref] PxConvexMeshDesc desc, [Ref] PxPhysicsInsertionCallback insertionCallback);
    PxTriangleMesh createTriangleMesh([Const, Ref] PxTriangleMeshDesc desc, [Ref] PxPhysicsInsertionCallback insertionCallback);
    PxHeightField createHeightField([Const, Ref] PxHeightFieldDesc desc, [Ref] PxPhysicsInsertionCallback insertionCallback);
};

[Prefix="physx::"]
interface PxCookingParams {
    void PxCookingParams([Const, Ref] PxTolerancesScale sc);
    attribute float areaTestEpsilon;
    attribute float planeTolerance;
    attribute PxConvexMeshCookingTypeEnum convexMeshCookingType;
    attribute boolean suppressTriangleMeshRemapTable;
    attribute boolean buildTriangleAdjacencies;
    attribute boolean buildGPUData;
    [Value] attribute PxTolerancesScale scale;
    [Value] attribute PxMeshPreprocessingFlags meshPreprocessParams;
    attribute float meshWeldTolerance;
    [Value] attribute PxMidphaseDesc midphaseDesc;
    attribute unsigned long gaussMapLimit;
};

enum PxMeshCookingHintEnum {
    "PxMeshCookingHintEnum::eSIM_PERFORMANCE",
    "PxMeshCookingHintEnum::eCOOKING_PERFORMANCE"
};

enum PxMeshPreprocessingFlagEnum {
    "PxMeshPreprocessingFlagEnum::eWELD_VERTICES",
    "PxMeshPreprocessingFlagEnum::eDISABLE_CLEAN_MESH",
    "PxMeshPreprocessingFlagEnum::eDISABLE_ACTIVE_EDGES_PRECOMPUTE",
    "PxMeshPreprocessingFlagEnum::eFORCE_32BIT_INDICES"
};

[Prefix="physx::"]
interface PxMeshPreprocessingFlags {
    void PxMeshPreprocessingFlags(unsigned long flags);
    boolean isSet(PxMeshPreprocessingFlagEnum flag);
    void set(PxMeshPreprocessingFlagEnum flag);
    void clear(PxMeshPreprocessingFlagEnum flag);
};

[Prefix="physx::"]
interface PxMidphaseDesc {
    void PxMidphaseDesc();
    PxMeshMidPhaseEnum getType();
    void setToDefault(PxMeshMidPhaseEnum type);
    boolean isValid();

    [Value] attribute PxBVH33MidphaseDesc mBVH33Desc;
    [Value] attribute PxBVH34MidphaseDesc mBVH34Desc;
};

enum PxMeshMidPhaseEnum {
    "PxMeshMidPhaseEnum::eBVH33",
    "PxMeshMidPhaseEnum::eBVH34"
};

[Prefix="physx::"]
interface PxTriangleMeshDesc {
    void PxTriangleMeshDesc();
    void setToDefault();
    boolean isValid();

    [Value] attribute PxU16StridedData materialIndices;
};
PxTriangleMeshDesc implements PxSimpleTriangleMesh;

/****************************************
 * [package=common]
 ****************************************/

[Prefix="physx::", NoDelete]
interface PxBase {
    void release();
    [Const] DOMString getConcreteTypeName();
    long getConcreteType();
    void setBaseFlag(PxBaseFlagEnum flag, boolean value);
    void setBaseFlags([Ref] PxBaseFlags inFlags);
    [Value] PxBaseFlags getBaseFlags();
    boolean isReleasable();
};

enum PxBaseFlagEnum {
    "PxBaseFlagEnum::eOWNS_MEMORY",
    "PxBaseFlagEnum::eIS_RELEASABLE"
};

[Prefix="physx::"]
interface PxBaseFlags {
    void PxBaseFlags(unsigned short flags);
    boolean isSet(PxBaseFlagEnum flag);
    void set(PxBaseFlagEnum flag);
    void clear(PxBaseFlagEnum flag);
};

[Prefix="physx::"]
interface PxBaseTask { };

[Prefix="physx::"]
interface PxBoundedData {
    void PxBoundedData();
    attribute unsigned long count;
    attribute unsigned long stride;
    [Const] attribute VoidPtr data;
};

[Prefix="physx::"]
interface PxBounds3 {
    void PxBounds3();
    void PxBounds3([Const, Ref] PxVec3 minimum, [Const, Ref] PxVec3 maximum);
    void setEmpty();
    void setMaximal();
    void include([Const, Ref] PxVec3 v);
    boolean isEmpty();
    boolean intersects([Const, Ref] PxBounds3 b);
    boolean intersects1D([Const, Ref] PxBounds3 b, unsigned long axis);
    boolean contains([Const, Ref] PxVec3 v);
    boolean isInside([Const, Ref] PxBounds3 box);
    [Value] PxVec3 getCenter();
    [Value] PxVec3 getDimensions();
    [Value] PxVec3 getExtents();
    void scaleSafe(float scale);
    void scaleFast(float scale);
    void fattenSafe(float distance);
    void fattenFast(float distance);
    boolean isFinite();
    boolean isValid();
    [Value] attribute PxVec3 minimum;
    [Value] attribute PxVec3 maximum;
};

[Prefix="physx::"]
interface PxCpuDispatcher { };

[Prefix="physx::", NoDelete]
interface PxCudaContextManager {
    boolean contextIsValid();
    boolean supportsArchSM10();
    boolean supportsArchSM11();
    boolean supportsArchSM12();
    boolean supportsArchSM13();
    boolean supportsArchSM20();
    boolean supportsArchSM30();
    boolean supportsArchSM35();
    boolean supportsArchSM50();
    boolean supportsArchSM52();
    boolean isIntegrated();
    boolean canMapHostMemory();
    long getDriverVersion();
    unsigned long long getDeviceTotalMemBytes();
    long getMultiprocessorCount();
    unsigned long getClockRate();
    long getSharedMemPerBlock();
    long getMaxThreadsPerBlock();
    [Const] DOMString getDeviceName();
    PxCudaInteropModeEnum getInteropMode();
    void setUsingConcurrentStreams(boolean flag);
    boolean getUsingConcurrentStreams();
    long usingDedicatedGPU();
    void release();
};

[Prefix="physx::"]
interface PxCudaContextManagerDesc {
    void PxCudaContextManagerDesc();
    attribute VoidPtr graphicsDevice;
    attribute PxCudaInteropModeEnum interopMode;
    attribute unsigned long[] maxMemorySize;
    attribute unsigned long[] memoryBaseSize;
    attribute unsigned long[] memoryPageSize;
};

enum PxCudaBufferMemorySpaceEnum {
    "PxCudaBufferMemorySpaceEnum::T_GPU",
    "PxCudaBufferMemorySpaceEnum::T_PINNED_HOST",
    "PxCudaBufferMemorySpaceEnum::T_WRITE_COMBINED",
    "PxCudaBufferMemorySpaceEnum::T_HOST",
};

enum PxCudaInteropModeEnum {
    "PxCudaInteropModeEnum::NO_INTEROP",
    "PxCudaInteropModeEnum::D3D10_INTEROP",
    "PxCudaInteropModeEnum::D3D11_INTEROP",
    "PxCudaInteropModeEnum::OGL_INTEROP"
};

[Prefix="physx::"]
interface PxDefaultErrorCallback {
    void PxDefaultErrorCallback();
};
PxDefaultErrorCallback implements PxErrorCallback;

[Prefix="physx::"]
interface PxErrorCallback {
    void reportError(PxErrorCodeEnum code, [Const] DOMString message, [Const] DOMString file, long line);
};

[JSImplementation="PxErrorCallback"]
interface JavaErrorCallback {
    void JavaErrorCallback();
    void reportError(PxErrorCodeEnum code, [Const] DOMString message, [Const] DOMString file, long line);
};

enum PxErrorCodeEnum {
    "PxErrorCodeEnum::eNO_ERROR",
    "PxErrorCodeEnum::eDEBUG_INFO",
    "PxErrorCodeEnum::eDEBUG_WARNING",
    "PxErrorCodeEnum::eINVALID_PARAMETER",
    "PxErrorCodeEnum::eINVALID_OPERATION",
    "PxErrorCodeEnum::eOUT_OF_MEMORY",
    "PxErrorCodeEnum::eINTERNAL_ERROR",
    "PxErrorCodeEnum::eABORT",
    "PxErrorCodeEnum::ePERF_WARNING",
    "PxErrorCodeEnum::eMASK_ALL"
};

[Prefix="physx::", NoDelete]
interface PxFoundation {
    void release();
};

enum PxIDENTITYEnum {
    "PxIDENTITYEnum::PxIdentity"
};

[Prefix="physx::", NoDelete]
interface PxPhysicsInsertionCallback { };

[Prefix="physx::"]
interface PxQuat {
    void PxQuat();
    void PxQuat(float x, float y, float z, float w);
    attribute float x;
    attribute float y;
    attribute float z;
    attribute float w;
};

[Prefix="physx::"]
interface PxTolerancesScale {
    void PxTolerancesScale();
};

[Prefix="physx::"]
interface PxTransform {
    void PxTransform(PxIDENTITYEnum r);
    void PxTransform([Const, Ref] PxVec3 p0, [Const, Ref] PxQuat q0);
    [Value] attribute PxQuat q;
    [Value] attribute PxVec3 p;
};

[Prefix="physx::"]
interface PxStridedData {
    attribute unsigned long stride;
    [Const] attribute VoidPtr data;
};

interface PxU16StridedData {
    attribute unsigned long stride;
    [Const, Value] attribute PxU16ConstPtr data;
};

[Prefix="physx::"]
interface PxVec3 {
    void PxVec3();
    void PxVec3(float x, float y, float z);
    attribute float x;
    attribute float y;
    attribute float z;
};

/****************************************
 * [package=extensions]
 ****************************************/

enum PxD6AxisEnum {
    "PxD6AxisEnum::eX",
    "PxD6AxisEnum::eY",
    "PxD6AxisEnum::eZ",
    "PxD6AxisEnum::eTWIST",
    "PxD6AxisEnum::eSWING1",
    "PxD6AxisEnum::eSWING2",
    "PxD6AxisEnum::eCOUNT"
};

enum PxD6DriveEnum {
    "PxD6DriveEnum::eX",
    "PxD6DriveEnum::eY",
    "PxD6DriveEnum::eZ",
    "PxD6DriveEnum::eSWING",
    "PxD6DriveEnum::eTWIST",
    "PxD6DriveEnum::eSLERP",
    "PxD6DriveEnum::eCOUNT"
};

[Prefix="physx::"]
interface PxD6Joint {
    void setMotion(PxD6AxisEnum axis, PxD6MotionEnum type);
    PxD6MotionEnum getMotion(PxD6AxisEnum axis);
    float getTwistAngle();
    float getSwingYAngle();
    float getSwingZAngle();
    void setDistanceLimit([Const, Ref] PxJointLinearLimit limit);
    //[Value] PxJointLinearLimit getDistanceLimit();
    void setLinearLimit(PxD6AxisEnum axis, [Const, Ref] PxJointLinearLimitPair limit);
    //[Value] PxJointLinearLimitPair getLinearLimit(PxD6AxisEnum axis);
    void setTwistLimit([Const, Ref] PxJointAngularLimitPair limit);
    //[Value] PxJointAngularLimitPair getTwistLimit();
    void setSwingLimit([Const, Ref] PxJointLimitCone limit);
    //[Value] PxJointLimitCone getSwingLimit();
    void setPyramidSwingLimit([Const, Ref] PxJointLimitPyramid limit);
    //[Value] PxJointLimitPyramid getPyramidSwingLimit();
    void setDrive(PxD6DriveEnum index, [Const, Ref] PxD6JointDrive drive);
    [Value] PxD6JointDrive getDrive(PxD6DriveEnum index);
    void setDrivePosition([Const, Ref] PxTransform pose, optional boolean autowake);
    [Value] PxTransform getDrivePosition();
    void setDriveVelocity([Const, Ref] PxVec3 linear, [Const, Ref] PxVec3 angular);
    void getDriveVelocity([Ref] PxVec3 linear, [Ref] PxVec3 angular);
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};

[Prefix="physx::"]
interface PxD6JointDrive {
    void PxD6JointDrive();
    void PxD6JointDrive(float driveStiffness, float driveDamping, float driveForceLimit, optional boolean isAcceleration);

    attribute float forceLimit;
    [Value] attribute PxD6JointDriveFlags flags;
};
PxD6JointDrive implements PxSpring;

enum PxD6JointDriveFlagEnum {
    "PxD6JointDriveFlagEnum::eACCELERATION"
};

[Prefix="physx::"]
interface PxD6JointDriveFlags {
    void PxD6JointDriveFlags(unsigned long flags);
    boolean isSet(PxD6JointDriveFlagEnum flag);
    void set(PxD6JointDriveFlagEnum flag);
    void clear(PxD6JointDriveFlagEnum flag);
};

enum PxD6MotionEnum {
    "PxD6MotionEnum::eLOCKED",
    "PxD6MotionEnum::eLIMITED",
    "PxD6MotionEnum::eFREE"
};

[Prefix="physx::"]
interface PxDefaultAllocator {
    void PxDefaultAllocator();
};

[Prefix="physx::"]
interface PxDefaultCpuDispatcher { };
PxDefaultCpuDispatcher implements PxCpuDispatcher;

[Prefix="physx::"]
interface PxDistanceJoint {
    float getDistance();
    void setMinDistance(float distance);
    float getMinDistance();
    void setMaxDistance(float distance);
    float getMaxDistance();
    void setTolerance(float tolerance);
    float getTolerance();
    void setStiffness(float stiffness);
    float getStiffness();
    void setDamping(float damping);
    float getDamping();
    void setDistanceJointFlags([Ref] PxDistanceJointFlags flags);
    void setDistanceJointFlag(PxDistanceJointFlagEnum flag, boolean value);
    [Value] PxDistanceJointFlags getDistanceJointFlags();
};
PxDistanceJoint implements PxJoint;

enum PxDistanceJointFlagEnum {
    "PxDistanceJointFlagEnum::eMAX_DISTANCE_ENABLED",
    "PxDistanceJointFlagEnum::eMIN_DISTANCE_ENABLED",
    "PxDistanceJointFlagEnum::eSPRING_ENABLED"
};

[Prefix="physx::"]
interface PxDistanceJointFlags {
    void PxDistanceJointFlags(unsigned short flags);
    boolean isSet(PxDistanceJointFlagEnum flag);
    void set(PxDistanceJointFlagEnum flag);
    void clear(PxDistanceJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxFixedJoint {
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};
PxFixedJoint implements PxJoint;

[Prefix="physx::", NoDelete]
interface PxJoint {
    void setActors(PxRigidActor actor0, PxRigidActor actor1);
    //void getActors(PxRigidActor actor0, PxRigidActor actor1);
    void setLocalPose(PxJointActorIndexEnum actor, [Const, Ref] PxTransform localPose);
    [Value] PxTransform getLocalPose(PxJointActorIndexEnum actor);
    [Value] PxTransform getRelativeTransform();
    [Value] PxVec3 getRelativeLinearVelocity();
    [Value] PxVec3 getRelativeAngularVelocity();
    void setBreakForce(float force, float torque);
    //void getBreakForce(float force, float torque);
    void setConstraintFlags([Ref] PxConstraintFlags flags);
    void setConstraintFlag(PxConstraintFlagEnum flag, boolean value);
    [Value] PxConstraintFlags getConstraintFlags();
    void setInvMassScale0(float invMassScale);
    float getInvMassScale0();
    void setInvMassScale1(float invMassScale);
    float getInvMassScale1();
    PxConstraint getConstraint();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    void release();
    PxScene getScene();
};
PxJoint implements PxBase;

enum PxJointActorIndexEnum {
    "PxJointActorIndexEnum::eACTOR0",
    "PxJointActorIndexEnum::eACTOR1",
    "PxJointActorIndexEnum::COUNT"
};

[Prefix="physx::"]
interface PxJointAngularLimitPair {
    // javascript bindings do not support overloaded functions with same parameter count
    //void PxJointAngularLimitPair(float lowerLimit, float upperLimit, optional float contactDist);
    void PxJointAngularLimitPair(float lowerLimit, float upperLimit, [Const, Ref] PxSpring spring);

    attribute float upper;
    attribute float lower;
};
PxJointAngularLimitPair implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLimitCone {
    // javascript bindings do not support overloaded functions with same parameter count
    //void PxJointLimitCone(float yLimitAngle, float zLimitAngle, optional float contactDist);
    void PxJointLimitCone(float yLimitAngle, float zLimitAngle, [Const, Ref] PxSpring spring);

    attribute float yAngle;
    attribute float zAngle;
};
PxJointLimitCone implements PxJointLimitParameters;

[Prefix="physx::", NoDelete]
interface PxJointLimitParameters {
    boolean isValid();
    boolean isSoft();

    attribute float restitution;
    attribute float bounceThreshold;
    attribute float stiffness;
    attribute float damping;
    attribute float contactDistance;
};

[Prefix="physx::"]
interface PxJointLimitPyramid {
    // javascript bindings do not support overloaded functions with same parameter count
    //void PxJointLimitPyramid(float yLimitAngleMin, float yLimitAngleMax, float zLimitAngleMin, float zLimitAngleMax, optional float contactDist);
    void PxJointLimitPyramid(float yLimitAngleMin, float yLimitAngleMax, float zLimitAngleMin, float zLimitAngleMax, [Const, Ref] PxSpring spring);

    attribute float yAngleMin;
    attribute float yAngleMax;
    attribute float zAngleMin;
    attribute float zAngleMax;
};
PxJointLimitPyramid implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLinearLimit {
    // javascript bindings do not support overloaded functions with same parameter count
    //void PxJointLinearLimit([Const, Ref] PxTolerancesScale scale, float extent, optional float contactDist);
    void PxJointLinearLimit(float extent, [Const, Ref] PxSpring spring);

    attribute float value;
};
PxJointLinearLimitPair implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLinearLimitPair {
    // javascript bindings do not support overloaded functions with same parameter count
    //void PxJointLinearLimitPair([Const, Ref] PxTolerancesScale scale, optional float lowerLimit, optional float upperLimit, optional float contactDist);
    void PxJointLinearLimitPair(float lowerLimit, float upperLimit, [Const, Ref] PxSpring spring);

    attribute float upper;
    attribute float lower;
};
PxJointLinearLimitPair implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxPrismaticJoint {
    float getPosition();
    float getVelocity();
    void setLimit([Const, Ref] PxJointLinearLimitPair limit);
    //[Value] PxJointLinearLimitPair getLimit();
    void setPrismaticJointFlags([Ref] PxPrismaticJointFlags flags);
    void setPrismaticJointFlag(PxPrismaticJointFlagEnum flag, boolean value);
    [Value] PxPrismaticJointFlags getPrismaticJointFlags();
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};
PxPrismaticJoint implements PxJoint;

enum PxPrismaticJointFlagEnum {
    "PxPrismaticJointFlagEnum::eLIMIT_ENABLED"
};

[Prefix="physx::"]
interface PxPrismaticJointFlags {
    void PxPrismaticJointFlags(unsigned short flags);
    boolean isSet(PxPrismaticJointFlagEnum flag);
    void set(PxPrismaticJointFlagEnum flag);
    void clear(PxPrismaticJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxRigidActorExt {
    static PxShape createExclusiveShape([Ref] PxRigidActor actor, [Const, Ref] PxGeometry geometry, [Const, Ref] PxMaterial material, [Ref] optional PxShapeFlags flags);
};

[Prefix="physx::"]
interface PxRigidBodyExt {
    //static boolean updateMassAndInertia([Ref] PxRigidBody body, [Ref] PxRealPtr shapeDensities, unsigned long shapeDensityCount, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);
    static boolean updateMassAndInertia([Ref] PxRigidBody body, float density, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);
    //static boolean setMassAndUpdateInertia([Ref] PxRigidBody body, [Ref] PxRealPtr shapeMasses, unsigned long shapeMassCount, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);
    static boolean setMassAndUpdateInertia([Ref] PxRigidBody body, float mass, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);

    static void addForceAtPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addForceAtLocalPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addLocalForceAtPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addLocalForceAtLocalPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);

    [Value] static PxVec3 getVelocityAtPos([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    [Value] static PxVec3 getLocalVelocityAtLocalPos([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    [Value] static PxVec3 getVelocityAtOffset([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);

    static void computeVelocityDeltaFromImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 impulsiveForce,
                [Const, Ref] PxVec3 impulsiveTorque, [Ref] PxVec3 deltaLinearVelocity, [Ref] PxVec3 deltaAngularVelocity);
    static void computeVelocityDeltaFromImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxTransform globalPose, [Const, Ref] PxVec3 point,
                [Const, Ref] PxVec3 impulse, float invMassScale, float invInertiaScale,
                [Ref] PxVec3 deltaLinearVelocity, [Ref] PxVec3 deltaAngularVelocity);
    static void computeLinearAngularImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxTransform globalPose, [Const, Ref] PxVec3 point,
                [Const, Ref] PxVec3 impulse, float invMassScale, float invInertiaScale,
                [Ref] PxVec3 linearImpulse, [Ref] PxVec3 angularImpulse);
};

[Prefix="physx::"]
interface PxRevoluteJoint {
    float getAngle();
    float getVelocity();
    void setLimit([Const, Ref] PxJointAngularLimitPair limits);
    //[Value] PxJointAngularLimitPair getLimit();
    void setDriveVelocity(float velocity, optional boolean autowake);
    float getDriveVelocity();
    void setDriveForceLimit(float limit);
    float getDriveForceLimit();
    void setDriveGearRatio(float ratio);
    float getDriveGearRatio();
    void setRevoluteJointFlags([Ref] PxRevoluteJointFlags flags);
    void setRevoluteJointFlag(PxRevoluteJointFlagEnum flag, boolean value);
    [Value] PxRevoluteJointFlags getRevoluteJointFlags();
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};
PxRevoluteJoint implements PxJoint;

enum PxRevoluteJointFlagEnum {
    "PxRevoluteJointFlagEnum::eLIMIT_ENABLED",
    "PxRevoluteJointFlagEnum::eDRIVE_ENABLED",
    "PxRevoluteJointFlagEnum::eDRIVE_FREESPIN"
};

[Prefix="physx::"]
interface PxRevoluteJointFlags {
    void PxRevoluteJointFlags(unsigned short flags);
    boolean isSet(PxRevoluteJointFlagEnum flag);
    void set(PxRevoluteJointFlagEnum flag);
    void clear(PxRevoluteJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxSphericalJoint {
    //[Value] PxJointLimitCone getLimitCone();
    void setLimitCone([Const, Ref] PxJointLimitCone limitCone);
    float getSwingYAngle();
    float getSwingZAngle();
    void setSphericalJointFlags([Ref] PxSphericalJointFlags flags);
    void setSphericalJointFlag(PxSphericalJointFlagEnum flag, boolean value);
    [Value] PxSphericalJointFlags getSphericalJointFlags();
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
};
PxSphericalJoint implements PxJoint;

enum PxSphericalJointFlagEnum {
    "PxSphericalJointFlagEnum::eLIMIT_ENABLED"
};

[Prefix="physx::"]
interface PxSphericalJointFlags {
    void PxSphericalJointFlags(unsigned short flags);
    boolean isSet(PxSphericalJointFlagEnum flag);
    void set(PxSphericalJointFlagEnum flag);
    void clear(PxSphericalJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxSpring {
    void PxSpring(float stiffness, float damping);
    attribute float stiffness;
    attribute float damping;
};

interface BatchVehicleUpdateDesc {
    void BatchVehicleUpdateDesc();
    attribute PxFoundation foundation;
    attribute PxScene scene;
    attribute PxVehicleDrivableSurfaceToTireFrictionPairs frictionPairs;
    attribute unsigned long maxNbVehicles;
    attribute unsigned long maxNbWheelsPerVehicle;
    attribute unsigned long maxNbHitPointsPerWheel;
    attribute unsigned long numWorkers;
    attribute unsigned long batchSize;
    [Value] attribute PxBatchQueryPreFilterShader preFilterShader;
    [Value] attribute PxBatchQueryPostFilterShader postFilterShader;
};

interface BatchVehicleUpdate {
    void BatchVehicleUpdate([Ref] BatchVehicleUpdateDesc desc);
    void addVehicle(PxVehicleWheels vehicle);
    void removeVehicle(PxVehicleWheels vehicle);
    void removeAllVehicles();
    long indexOf(PxVehicleWheels vehicle);
    void batchUpdate(float timestep);
    PxWheelQueryResult getWheelQueryResult(unsigned long vehicleId, unsigned long wheelId);
};

/****************************************
 * [package=character]
 ****************************************/

[Prefix="physx::", NoDelete]
interface PxBoxController {
    float getHalfHeight();
    float getHalfSideExtent();
    float getHalfForwardExtent();
    void setHalfHeight(float halfHeight);
    void setHalfSideExtent(float halfSideExtent);
    void setHalfForwardExtent(float halfForwardExtent);
};
PxBoxController implements PxController;

[Prefix="physx::"]
interface PxBoxControllerDesc {
    void PxBoxControllerDesc();
    void setToDefault();
    boolean isValid();
    attribute float halfHeight;
    attribute float halfSideExtent;
    attribute float halfForwardExtent;
};
PxBoxControllerDesc implements PxControllerDesc;

[Prefix="physx::"]
interface PxBoxObstacle {
    void PxBoxObstacle();
    [Value] attribute PxVec3 mHalfExtents;
};
PxBoxObstacle implements PxObstacle;

enum PxCapsuleClimbingModeEnum {
    "PxCapsuleClimbingModeEnum::eEASY",
    "PxCapsuleClimbingModeEnum::eCONSTRAINED"
};

[Prefix="physx::", NoDelete]
interface PxCapsuleController {
    float getRadius();
    void setRadius(float radius);
    float getHeight();
    void setHeight(float height);
    PxCapsuleClimbingModeEnum getClimbingMode();
    boolean setClimbingMode(PxCapsuleClimbingModeEnum mode);
};
PxCapsuleController implements PxController;

[Prefix="physx::"]
interface PxCapsuleControllerDesc {
    void PxCapsuleControllerDesc();
    void setToDefault();
    boolean isValid();
    attribute float radius;
    attribute float height;
    attribute PxCapsuleClimbingModeEnum climbingMode;
};
PxCapsuleControllerDesc implements PxControllerDesc;

[Prefix="physx::"]
interface PxCapsuleObstacle {
    void PxCapsuleObstacle();
    attribute float mHalfHeight;
    attribute float mRadius;
};
PxCapsuleObstacle implements PxObstacle;

[Prefix="physx::", NoDelete]
interface PxController {
    PxControllerShapeTypeEnum getType();
    void release();
    [Value] PxControllerCollisionFlags move([Const, Ref] PxVec3 disp, float minDist, float elapsedTime, [Const, Ref] PxControllerFilters filters, [Const] optional PxObstacleContext obstacles);
    boolean setPosition([Const, Ref] PxExtendedVec3 position);
    [Const, Ref] PxExtendedVec3 getPosition();
    boolean setFootPosition([Const, Ref] PxExtendedVec3 position);
    [Value] PxExtendedVec3 getFootPosition();
    PxRigidDynamic getActor();
    void setStepOffset(float offset);
    float getStepOffset();
    void setNonWalkableMode(PxControllerNonWalkableModeEnum flag);
    PxControllerNonWalkableModeEnum getNonWalkableMode();
    float getContactOffset();
    void setContactOffset(float offset);
    [Value] PxVec3 getUpDirection();
    void setUpDirection([Const, Ref] PxVec3 up);
    float getSlopeLimit();
    void setSlopeLimit(float slopeLimit);
    void invalidateCache();
    PxScene getScene();
    VoidPtr getUserData();
    void setUserData(VoidPtr userData);
    void getState([Ref] PxControllerState state);
    void getStats([Ref] PxControllerStats stats);
    void resize(float height);
};

enum PxControllerCollisionFlagEnum {
    "PxControllerCollisionFlagEnum::eCOLLISION_SIDES",
    "PxControllerCollisionFlagEnum::eCOLLISION_UP",
    "PxControllerCollisionFlagEnum::eCOLLISION_DOWN"
};

[Prefix="physx::"]
interface PxControllerCollisionFlags {
    void PxControllerCollisionFlags(octet flags);
    boolean isSet(PxControllerCollisionFlagEnum flag);
    void set(PxControllerCollisionFlagEnum flag);
    void clear(PxControllerCollisionFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxControllerDesc {
    boolean isValid();
    PxControllerShapeTypeEnum getType();
    [Value] attribute PxExtendedVec3 position;
    [Value] attribute PxVec3 upDirection;
    attribute float slopeLimit;
    attribute float invisibleWallHeight;
    attribute float maxJumpHeight;
    attribute float contactOffset;
    attribute float stepOffset;
    attribute float density;
    attribute float scaleCoeff;
    attribute float volumeGrowth;
    attribute PxUserControllerHitReport reportCallback;
    //attribute PxControllerBehaviorCallback behaviorCallback;
    attribute PxControllerNonWalkableModeEnum nonWalkableMode;
    attribute PxMaterial material;
    attribute boolean registerDeletionListener;
    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxControllerFilters {
    void PxControllerFilters([Const] optional PxFilterData filterData);
    [Const] attribute PxFilterData mFilterData;
    // PxQueryFilterCallback mFilterCallback;
    [Value] attribute PxQueryFlags mFilterFlags;
    // PxControllerFilterCallback mCCTFilterCallback;
};

[Prefix="physx::"]
interface PxControllerHit {
    attribute PxController controller;
    [Value] attribute PxExtendedVec3 worldPos;
    [Value] attribute PxVec3 worldNormal;
    [Value] attribute PxVec3 dir;
    attribute float length;
};

[Prefix="physx::", NoDelete]
interface PxControllerManager {
    void release();
    [Ref] PxScene getScene();
    unsigned long getNbControllers();
    PxController getController(unsigned long index);
    PxController createController([Const, Ref] PxControllerDesc desc);
    void purgeControllers();
    // [Ref] RenderBuffer getRenderBuffer();
    // void setDebugRenderingFlags(...);
    unsigned long getNbObstacleContexts();
    PxObstacleContext getObstacleContext(unsigned long index);
    PxObstacleContext createObstacleContext();
    void computeInteractions(float elapsedTime);
    void setTessellation(boolean flag, float maxEdgeLength);
    void setOverlapRecoveryModule(boolean flag);
    void setPreciseSweeps(boolean flags);
    void setPreventVerticalSlidingAgainstCeiling(boolean flag);
    void shiftOrigin([Const, Ref] PxVec3 shift);
};

enum PxControllerNonWalkableModeEnum {
    "PxControllerNonWalkableModeEnum::ePREVENT_CLIMBING",
    "PxControllerNonWalkableModeEnum::ePREVENT_CLIMBING_AND_FORCE_SLIDING"
};

[Prefix="physx::"]
interface PxControllerObstacleHit {
    [Const] attribute VoidPtr userData;
};
PxControllerObstacleHit implements PxControllerHit;

[Prefix="physx::"]
interface PxControllerShapeHit {
    attribute PxShape shape;
    attribute PxRigidActor actor;
    attribute unsigned long triangleIndex;
};
PxControllerShapeHit implements PxControllerHit;

[Prefix="physx::"]
interface PxControllersHit {
    attribute PxController other;
};
PxControllersHit implements PxControllerHit;

enum PxControllerShapeTypeEnum {
    "PxControllerShapeTypeEnum::eBOX",
    "PxControllerShapeTypeEnum::eCAPSULE"
};

[Prefix="physx::"]
interface PxControllerState {
    void PxControllerState();
    [Value] attribute PxVec3 deltaXP;
    attribute PxShape touchedShape;
    attribute PxRigidActor touchedActor;
    attribute unsigned long touchedObstacleHandle;
    attribute unsigned long collisionFlags;
    attribute boolean standOnAnotherCCT;
    attribute boolean standOnObstacle;
    attribute boolean isMovingUp;
};

[Prefix="physx::"]
interface PxControllerStats {
    attribute unsigned short nbIterations;
    attribute unsigned short nbFullUpdates;
    attribute unsigned short nbPartialUpdates;
    attribute unsigned short nbTessellation;
};

[Prefix="physx::"]
interface PxExtendedVec3 {
    void PxExtendedVec3();
    void PxExtendedVec3(double x, double y, double z);
    attribute double x;
    attribute double y;
    attribute double z;
};

[Prefix="physx::"]
interface PxObstacle {
    PxGeometryTypeEnum getType();
    attribute VoidPtr mUserData;
    [Value] attribute PxExtendedVec3 mPos;
    [Value] attribute PxQuat mRot;
};

[Prefix="physx::"]
interface PxObstacleContext {
    void release();
    [Ref] PxControllerManager getControllerManager();
    unsigned long addObstacle([Const, Ref] PxObstacle obstacle);
    boolean removeObstacle(unsigned long handle);
    boolean updateObstacle(unsigned long handle, [Const, Ref] PxObstacle obstacle);
    unsigned long getNbObstacles();
    [Const] PxObstacle getObstacle(unsigned long i);
    [Const] PxObstacle getObstacleByHandle(unsigned long handle);
};

[Prefix="physx::", NoDelete]
interface PxUserControllerHitReport {
    void onShapeHit([Const, Ref] PxControllerShapeHit hit);
    void onControllerHit([Const, Ref] PxControllersHit hit);
    void onObstacleHit([Const, Ref] PxControllerObstacleHit hit);
};

[JSImplementation="PxUserControllerHitReport"]
interface JavaUserControllerHitReport {
    void JavaUserControllerHitReport();
    void onShapeHit([Const, Ref] PxControllerShapeHit hit);
    void onControllerHit([Const, Ref] PxControllersHit hit);
    void onObstacleHit([Const, Ref] PxControllerObstacleHit hit);
};

/****************************************
 * [package=support]
 ****************************************/

interface SupportFunctions {
    static PxShape PxActor_getShape([Ref] PxRigidActor actor, long index);
};

interface PxActorPtr { };

interface PxMaterialPtr { };

interface PxMaterialConstPtr { };

interface PxVehicleWheelsPtr { };

interface PxRealPtr { };

interface PxU8Ptr { };

interface PxU8ConstPtr { };

interface PxU16Ptr { };

interface PxU16ConstPtr { };

interface PxU32Ptr { };

interface PxU32ConstPtr { };

interface TypeHelpers {
    static octet getU8At([Ref] PxU8ConstPtr base, long index);
    static unsigned short getU16At([Ref] PxU16ConstPtr base, long index);
    static unsigned long getU32At([Ref] PxU32ConstPtr base, long index);
    static float getRealAt([Ref] PxRealPtr base, long index);
    static PxContactPair getContactPairAt(PxContactPair base, long index);
    static PxTriggerPair getTriggerPairAt(PxTriggerPair base, long index);
    static PxContactPairHeader getContactPairHeaderAt(PxContactPairHeader base, long index);
    
    static PxControllerShapeHit getControllerShapeHitAt(PxControllerShapeHit base, long index);

    static PxShape getShapeAFromContactPair(PxContactPair base);
    static PxShape getShapeBFromContactPair(PxContactPair base);
    
    static PxVec3 getVec3At(PxVec3 base, long index);

    [Value] static PxU8ConstPtr voidToU8ConstPtr(VoidPtr voidPtr);
    [Value] static PxU16ConstPtr voidToU16ConstPtr(VoidPtr voidPtr);
    [Value] static PxU32ConstPtr voidToU32ConstPtr(VoidPtr voidPtr);
    [Value] static PxRealPtr voidToRealPtr(VoidPtr voidPtr);

    static PxArticulationJoint articulationBaseJointToJoint(PxArticulationJointBase baseJoint);

    static any voidToAny(VoidPtr voidPtr);
};

interface Vector_PxMaterialConst {
    void Vector_PxMaterialConst();
    void Vector_PxMaterialConst(unsigned long size);
    [Const] PxMaterial at(unsigned long index);
    PxMaterialConstPtr data();
    unsigned long size();
    void push_back([Const] PxMaterial value);
};

interface Vector_PxHeightFieldSample {
    void Vector_PxHeightFieldSample();
    void Vector_PxHeightFieldSample(unsigned long size);
    [Ref] PxHeightFieldSample at(unsigned long index);
    PxHeightFieldSample data();
    unsigned long size();
    void push_back([Ref] PxHeightFieldSample value);
};

interface Vector_PxReal {
    void Vector_PxReal();
    void Vector_PxReal(unsigned long size);
    float at(unsigned long index);
    VoidPtr data();
    unsigned long size();
    void push_back(float value);
};

interface Vector_PxU16 {
    void Vector_PxU16();
    void Vector_PxU16(unsigned long size);
    unsigned short at(unsigned long index);
    VoidPtr data();
    unsigned long size();
    void push_back(unsigned short value);
};

interface Vector_PxU32 {
    void Vector_PxU32();
    void Vector_PxU32(unsigned long size);
    unsigned long at(unsigned long index);
    VoidPtr data();
    unsigned long size();
    void push_back(unsigned long value);
};

interface Vector_PxVec3 {
    void Vector_PxVec3();
    void Vector_PxVec3(unsigned long size);
    [Ref] PxVec3 at(unsigned long index);
    PxVec3 data();
    unsigned long size();
    void push_back([Ref] PxVec3 value);
};

interface Vector_PxRaycastQueryResult {
    void Vector_PxRaycastQueryResult();
    void Vector_PxRaycastQueryResult(unsigned long size);
    [Ref] PxRaycastQueryResult at(unsigned long index);
    PxRaycastQueryResult data();
    unsigned long size();
    void push_back([Ref] PxRaycastQueryResult value);
};

interface Vector_PxSweepQueryResult {
    void Vector_PxSweepQueryResult();
    void Vector_PxSweepQueryResult(unsigned long size);
    [Ref] PxSweepQueryResult at(unsigned long index);
    PxSweepQueryResult data();
    unsigned long size();
    void push_back([Ref] PxSweepQueryResult value);
};

interface Vector_PxRaycastHit {
    void Vector_PxRaycastHit();
    void Vector_PxRaycastHit(unsigned long size);
    [Ref] PxRaycastHit at(unsigned long index);
    PxRaycastHit data();
    unsigned long size();
    void push_back([Ref] PxRaycastHit value);
};

interface Vector_PxSweepHit {
    void Vector_PxSweepHit();
    void Vector_PxSweepHit(unsigned long size);
    [Ref] PxSweepHit at(unsigned long index);
    PxSweepHit data();
    unsigned long size();
    void push_back([Ref] PxSweepHit value);
};

interface Vector_PxVehicleDrivableSurfaceType {
    void Vector_PxVehicleDrivableSurfaceType();
    void Vector_PxVehicleDrivableSurfaceType(unsigned long size);
    [Ref] PxVehicleDrivableSurfaceType at(unsigned long index);
    PxVehicleDrivableSurfaceType data();
    unsigned long size();
    void push_back([Ref] PxVehicleDrivableSurfaceType value);
};

interface Vector_PxWheelQueryResult {
    void Vector_PxWheelQueryResult();
    void Vector_PxWheelQueryResult(unsigned long size);
    [Ref] PxWheelQueryResult at(unsigned long index);
    PxWheelQueryResult data();
    unsigned long size();
    void push_back([Ref] PxWheelQueryResult value);
};

interface Vector_PxVehicleWheels {
    void Vector_PxVehicleWheels();
    void Vector_PxVehicleWheels(unsigned long size);
    PxVehicleWheels at(unsigned long index);
    PxVehicleWheelsPtr data();
    unsigned long size();
    void push_back(PxVehicleWheels value);
};

[Prefix = "physx::", NoDelete] interface PxPvdTransport {
    boolean connect();
    void disconnect();
    boolean isConnected();
};

interface SimplePvdTransport {
    void SimplePvdTransport();
    void send(long inBytes, long inLength);
};
SimplePvdTransport implements PxPvdTransport;

[JSImplementation="SimplePvdTransport"]
interface JSPvdTransport {
    void JSPvdTransport();
};
JSPvdTransport implements SimplePvdTransport;

enum PxPvdInstrumentationFlagEnum {
    "PxPvdInstrumentationFlagEnum::eDEBUG",
    "PxPvdInstrumentationFlagEnum::ePROFILE",
    "PxPvdInstrumentationFlagEnum::eMEMORY",
    "PxPvdInstrumentationFlagEnum::eALL"
};

[Prefix = "physx::"] interface PxPvdInstrumentationFlags
{
    void PxPvdInstrumentationFlags(octet flags);
    boolean isSet(PxPvdInstrumentationFlagEnum flag);
    void set(PxPvdInstrumentationFlagEnum flag);
    void clear(PxPvdInstrumentationFlagEnum flag);
};

[Prefix = "physx::", NoDelete] interface PxPvd
{
    boolean connect([Ref] PxPvdTransport transport, [Ref] PxPvdInstrumentationFlags flags);
};
